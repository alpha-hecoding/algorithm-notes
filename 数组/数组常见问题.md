# 27.移除元素
给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95) 修改输入数组**。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
## 题解
> 采用双指针方式
```java
public int removeElement(int[] nums, int val) {  
    int j = 0;  
    for (int i = 0; i < nums.length; i++) {  
        if (nums[i] != val) {  
            nums[j++] = nums[i];  
        }  
    }  
    return j;  
}
```
# 977.有序数组的平方
给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。
## 题解
> 要考虑有负数的情况，平方之后可能比后一位平方更大。采用双指针法，从两边到中间相向移动，谁的平方大则往前移动一步继续比较

```java
public int[] sortedSquares(int[] nums) {  
    int[] result = new int[nums.length];  
    int left = 0;  
    int right = nums.length - 1;  
    int index = nums.length - 1;  
    while (left <= right) {  
        if (nums[left] * nums[left] > nums[right] * nums[right]) {  
            result[index--] = nums[left] * nums[left];  
            left++;  
        } else {  
            result[index--] = nums[right] * nums[right];  
            right--;  
        }  
    }  
    return result;  
}
```
# 209.长度最小的子数组
给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度。**如果不存在符合条件的子数组，返回** `0` 。
## 题解
> 采用双指针方式的滑动窗口算法，动态调整窗口大小。

```java
public int minSubArrayLen(int target, int[] nums) {  
    int left = 0;  
    int right = 0;  
    int sum = 0;  
    int result = Integer.MAX_VALUE;  
    while (right < nums.length) {  
        sum += nums[right]; // 滑动窗口区间和  
        while (sum >= target) {  
            // 区间和符合条件，缩小区间  
            result = Math.min(result, right - left + 1);  
            sum -= nums[left++];  
        }  
        right++; // 扩大区间  
    }  
    return result == Integer.MAX_VALUE ? 0 : result;  
}
```
# 59.螺旋矩阵二
给你一个正整数 `n` ，生成一个包含 `1` 到 `n^2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。  
示例:    
输入: 3 输出: `[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]`  
## 题解
- 循环次数为n/2
- 每轮循环处理四条边，遵循一致性原则，处理头，尾交给下一条边处理
```java
public int[][] generateMatrix(int n) {  
    int[][] result = new int[n][n];  
    int i = 0; // 行坐标  
    int j = 0; // 列坐标  
    int k = 0; // 循环次数  
    int count = 1; // 填充数字  
    // 最大循环次数理论上为n/2  
    for (; k < n / 2; k++) {  
        // 从左到右，右边界不处理  
        for (j = k; j < n - k - 1; j++) {  
            result[i][j] = count++;  
        }  
        // 从上到下，下边界不处理  
        for (i = k; i < n - k - 1; i++) {  
            result[i][j] = count++;  
        }  
        // 从右到左，左边界不处理  
        for (j = n - k - 1; j > k; j--) {  
            result[i][j] = count++;  
        }  
        // 从下到上，上边界不处理  
        for (i = n - k - 1; i > k; i--) {  
            result[i][j] = count++;  
        }  
        // 每一轮循环完，回到起点，需要向下向右挪一位  
        i++;  
        j++;  
    }  
    // 奇数时处理中心点  
    if (n % 2 == 1) {  
        result[i][j] = count;  
    }  
    return result;  
}
```