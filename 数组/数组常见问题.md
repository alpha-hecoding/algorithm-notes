# 27.移除元素
> 采用双指针方式
```java
public int removeElement(int[] nums, int val) {  
    int j = 0;  
    for (int i = 0; i < nums.length; i++) {  
        if (nums[i] != val) {  
            nums[j++] = nums[i];  
        }  
    }  
    return j;  
}
```
# 977.有序数组的平方
> 采用双指针法，从两边到中间相向移动，谁的平方大则往前移动一步继续比较

```java
public int[] sortedSquares(int[] nums) {  
    int[] result = new int[nums.length];  
    int left = 0;  
    int right = nums.length - 1;  
    int index = nums.length - 1;  
    while (left <= right) {  
        if (nums[left] * nums[left] > nums[right] * nums[right]) {  
            result[index--] = nums[left] * nums[left];  
            left++;  
        } else {  
            result[index--] = nums[right] * nums[right];  
            right--;  
        }  
    }  
    return result;  
}
```
# 209.长度最小的子数组
> 有序的正整数数组中找到和大于等于给定数值的长度最小的连续子数组

```java
public int minSubArrayLen(int target, int[] nums) {  
    int left = 0;  
    int right = 0;  
    int sum = 0;  
    int result = Integer.MAX_VALUE;  
    while (right < nums.length) {  
        sum += nums[right]; // 滑动窗口区间和  
        while (sum >= target) {  
            // 区间和符合条件，缩小区间  
            result = Math.min(result, right - left + 1);  
            sum -= nums[left++];  
        }  
        right++; // 扩大区间  
    }  
    return result == Integer.MAX_VALUE ? 0 : result;  
}
```
# 59.螺旋矩阵二
> 给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵.  
> 示例:  
> 输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]  
```java
public int[][] generateMatrix(int n) {  
    int[][] result = new int[n][n];  
    int i = 0; // 行坐标  
    int j = 0; // 列坐标  
    int k = 0; // 循环次数  
    int count = 1; // 填充数字  
    // 最大循环次数理论上为n/2  
    for (; k < n / 2; k++) {  
        // 从左到右，右边界不处理  
        for (j = k; j < n - k - 1; j++) {  
            result[i][j] = count++;  
        }  
        // 从上到下，下边界不处理  
        for (i = k; i < n - k - 1; i++) {  
            result[i][j] = count++;  
        }  
        // 从右到左，左边界不处理  
        for (j = n - k - 1; j > k; j--) {  
            result[i][j] = count++;  
        }  
        // 从下到上，上边界不处理  
        for (i = n - k - 1; i > k; i--) {  
            result[i][j] = count++;  
        }  
        // 每一轮循环完，回到起点，需要向下向右挪一位  
        i++;  
        j++;  
    }  
    // 奇数时处理中心点  
    if (n % 2 == 1) {  
        result[i][j] = count;  
    }  
    return result;  
}
```