# 144.二叉树的前序遍历
> 递归方式
```java
public void traversal(TreeNode node, List<Integer> list) {  
    if (node == null) {  
        return;  
    }  
    list.add(node.val); // 处理根节点  
    traversal(node.left, list); // 遍历左子树  
    traversal(node.right, list); // 遍历右子树  
}  
  
public List<Integer> preorderTraversal(TreeNode root) {  
    List<Integer> list = new ArrayList<>();  
    traversal(root, list);  
    return list;  
}
```
> 迭代方式  
```java
public List<Integer> preorderTraversal(TreeNode root) {  
    List<Integer> list = new ArrayList<>();  
    // 用一个栈来记录访问顺序  
    Stack<TreeNode> stack = new Stack<>();  
    stack.push(root); // 先将根结点压入栈中  
    while (!stack.empty()) {  
        final TreeNode node = stack.pop();  
        if (node == null) {  
            continue;  
        }  
        list.add(node.val); // 前序遍历先处理当前结点  
        stack.push(node.right); // 前序遍历先将右孩子结点入栈  
        stack.push(node.left); // 前序遍历再将左孩子结点入栈  
    }  
    return list;  
}
```
# 145.二叉树的后序遍历
> 递归方式
```java
public void traversal(TreeNode node, List<Integer> list) {  
    if (node == null) {  
        return;  
    }  
    traversal(node.left, list); // 遍历左子树  
    traversal(node.right, list); // 遍历右子树  
    list.add(node.val); // 处理根节点  
}  
  
public List<Integer> postorderTraversal(TreeNode root) {  
    List<Integer> list = new ArrayList<>();  
    traversal(root, list);  
    return list;  
}
```
> 迭代方式，采用栈模拟遍历顺序
```java
public List<Integer> postorderTraversal(TreeNode root) {  
    List<Integer> list = new ArrayList<>();  
    if (root == null) {  
        return list;  
    }  
    // 用一个栈来记录访问顺序  
    Stack<TreeNode> stack = new Stack<>();  
    stack.push(root); // 先将根结点压入栈中  
    TreeNode lastPop = null; // 记录上一次栈中弹出元素  
    // 入栈顺序为 根、右、左  
    // 出栈顺序为 左、右、根  
    while (!stack.empty()) {  
        final TreeNode top = stack.peek(); // 栈顶元素  
        // 叶子结点，直接出栈；  
        // 上次出栈为栈顶右孩子节点，则栈顶元素也可以出栈；  
        // 上次出栈为栈顶左孩子结点且栈顶右孩子为空，则栈顶元素可以出栈  
        if ((top.right == null && top.left == null)  
                || (lastPop == top.right && top.right != null)  
                || (lastPop == top.left && top.right == null)) {  
            list.add(top.val);  
            lastPop = stack.pop();  
            continue;        
        }  
        // 先压入右孩子结点  
        if (top.right != null) {  
            stack.push(top.right);  
        }  
        // 再压入左孩子结点  
        if (top.left != null) {  
            stack.push(top.left);  
        }  
    }  
    return list;  
}
```
> 基于前序魔改方式：前序是`中左右`，调整为`中右左`再**翻转**下就是后序`左右中`了
```java
public List<Integer> postorderTraversal(TreeNode root) {  
    List<Integer> result = new ArrayList<>();  
    Stack<TreeNode> stack = new Stack<TreeNode>();  
    stack.push(root);  
    while (!stack.isEmpty()) {  
        TreeNode top = stack.pop();  
        if (top == null) {  
            continue;  
        }  
        result.add(top.val); // 处理中节点  
        stack.push(top.left); // 左孩子节点先入栈，后出栈  
        stack.push(top.right); // 右孩子节点后入栈，先出栈  
    }  
    // 按照出栈顺序为 中->右->左，翻转即可得到后序顺序：左->右->中  
    Collections.reverse(result);  
    return result;  
}
```
# 94.二叉树的中序遍历
> 递归方式
```java
public void traversal(TreeNode node, List<Integer> list) {  
    if (node == null) {  
        return;  
    }  
    traversal(node.left, list); // 遍历左子树  
    list.add(node.val); // 处理根节点  
    traversal(node.right, list); // 遍历右子树  
}  
  
public List<Integer> inorderTraversal(TreeNode root) {  
    List<Integer> list = new ArrayList<>();  
    traversal(root, list);  
    return list;  
}
```
> 迭代方式，用一个指针记录遍历顺序，用栈记录处理顺序  
> 遍历顺序为：根、左、右  
> 处理顺序为：左、根、右  
```java
public List<Integer> inorderTraversal(TreeNode root) {  
    List<Integer> result = new ArrayList<>();  
    if (root == null) {  
        return result;  
    }  
    // 用栈来记录处理顺序  
    Stack<TreeNode> stack = new Stack<TreeNode>();  
    TreeNode curr = root; // 指针记录遍历顺序  
    // 当前遍历指针不为空（未遍历到叶子节点） 或 栈不为空（有待处理的节点）  
    while (curr != null || !stack.isEmpty()) {  
        if (curr != null) {  
            // 遍历左孩子节点，并入栈，直到达到最远左孩子节点  
            stack.push(curr);  
            curr = curr.left;  
        } else {  
            // 最远左孩子节点，先出栈  
            TreeNode node = stack.pop();  
            result.add(node.val); // 取出遍历结果  
            // 有右子树，则继续遍历右子树，否则会继续出栈  
            if (node.right != null) {  
                curr = node.right; // 遍历右子树  
            }  
        }  
    }  
    return result;  
}
```
# 102.二叉树的层序遍历
> 用一个队列来保存每一层的结点。每处理完一个结点，则将其左右孩子结点加入到队列  
> 关键点是记录每层结点数量  
```java
public List<List<Integer>> levelOrder(TreeNode root) {  
    // 采用队列记录每层的结点数  
    Queue<TreeNode> queue = new LinkedList<>();  
    int levelSize = 0;  
    List<List<Integer>> ret = new ArrayList<>();  
    queue.add(root);  
    levelSize = 1; // 当前需要遍历的层的结点总数  
    while (!queue.isEmpty()) {  
        List<Integer> levelNodes = new ArrayList<>();  
        for (int i = 0; i < levelSize; i++) {  
            final TreeNode node = queue.poll();  
            if (node == null) {  
                continue;  
            }  
            levelNodes.add(node.val); // 获取层结点  
            queue.add(node.left); // 将该结点的下层左孩子结点添加到队列  
            queue.add(node.right); // 将该结点的下层右孩子结点添加到队列  
        }  
        if (levelNodes.size() > 0) {  
            ret.add(levelNodes);  
        }  
        levelSize = queue.size(); // 关键！当前队列中元素为下层所有结点  
    }  
    return ret;  
}
```
# 107.二叉树的层序遍历二
> 给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）  
## 题解
> 要求是自底向上，所以在自顶向下额基础上把结果翻转下即可 
```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {  
    List<List<Integer>> ret = new ArrayList<>();  
    if (root == null) {  
        return ret;  
    }  
    Queue<TreeNode> queue = new LinkedList<>();  
    queue.add(root);  
    int levelSize = 1;  
    while (!queue.isEmpty()) {  
        List<Integer> levelNodes = new ArrayList<>();  
        for (int i = 0; i < levelSize; i++) {  
            final TreeNode node = queue.poll();  
            levelNodes.add(node.val);  
            if (node.left != null) {  
                queue.add(node.left);  
            }  
            if (node.right != null) {  
                queue.add(node.right);  
            }  
        }  
        if (!levelNodes.isEmpty()) {  
            ret.add(levelNodes);  
        }  
        levelSize = queue.size();  
    }  
    // 翻转  
    Collections.reverse(ret);  
    return ret;  
}
```
# 199.二叉树的右视图
> 给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。  
## 题解
> 二叉树层序遍历输出每一层的最后一个结点
```java
public List<Integer> rightSideView(TreeNode root) {  
    List<Integer> ret = new ArrayList<>();  
    if (root == null) {  
        return ret;  
    }  
    Queue<TreeNode> queue = new LinkedList<>();  
    queue.add(root);  
    int levelSize = 1;  
    while (!queue.isEmpty()) {  
        for (int i = 0; i < levelSize; i++) {  
            TreeNode node = queue.poll();  
            // 每一层的最后一个结点输出  
            if (i == levelSize - 1) {  
                ret.add(node.val);  
            }  
            if (node.left != null) {  
                queue.add(node.left);  
            }  
            if (node.right != null) {  
                queue.add(node.right);  
            }  
        }  
        levelSize = queue.size();  
    }  
    return ret;  
}
```
# 429.N叉树的层序遍历
> 二叉树层序遍历的延伸
```java
public List<List<Integer>> levelOrder(Node root) {  
    List<List<Integer>> ret = new ArrayList<>();  
    if (root == null) {  
        return ret;  
    }  
    Queue<Node> queue = new LinkedList<>();  
    queue.add(root);  
    int levelSize = 1;  
    while (!queue.isEmpty()) {  
        List<Integer> levelNodes = new ArrayList<>();  
        for (int i = 0; i < levelSize; i++) {  
            final Node node = queue.poll();  
            levelNodes.add(node.val);  
            if (node.children != null) {  
                for (Node n : node.children) {  
                    if (n != null) {  
                        queue.add(n);  
                    }  
                }  
            }  
        }  
        if (!levelNodes.isEmpty()) {  
            ret.add(levelNodes);  
        }  
        levelSize = queue.size();  
    }  
    return ret;  
}
```
# 116.填充每个结点的下一个右侧指针结点
> 每一层的结点从左到右连起来组成链表  
> 层序遍历的应用场景之一，获取到层序结点时连接起来  
```java
public Node connect(Node root) {  
    if (root == null) {  
        return root;  
    }  
    Queue<Node> queue = new LinkedList<>();  
    queue.add(root);  
    int levelSize = 1;  
    while (!queue.isEmpty()) {  
        for (int i = 0; i < levelSize; i++) {  
            Node node = queue.poll();  
            if (i < levelSize - 1) {  
                node.next = queue.peek();  
            }  
            if (node.left != null) {  
                queue.add(node.left);  
            }  
            if (node.right != null) {  
                queue.add(node.right);  
            }  
        }  
        levelSize = queue.size();  
    }  
    return root;  
}
```
# 104.二叉树的最大深度
> 深度为根节点到该结点的距离  
```java
public int maxDepth(TreeNode root) {  
    if (root == null) {  
        return 0;  
    }  
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));  
}
```
# 111.二叉树的最小深度
> 计算根节点到叶子结点(叶子节点是指没有子节点的节点)的最短路径长度  
```java
public int minDepth(TreeNode root) {  
    if (root == null) {  
        return 0;  
    }  
    if (root.left == null && root.right == null) {  
        return 1;  
    } else if (root.left == null) {  
        return 1 + minDepth(root.right);  
    } else if (root.right == null) {  
        return 1 + minDepth(root.left);  
    } else {  
        return 1 + Math.min(minDepth(root.left), minDepth(root.right));  
    }  
}
```
# 100.相同的树
> 判断两个树有相同的结构且在相同的位置上有相同的节点值
```java
public boolean isSameTree(TreeNode p, TreeNode q) {  
    if (p == q) {  
        return true;  
    }  
    if ((p == null && q != null)  
            || (p != null && q == null)  
            || (p.val != q.val)) {  
        return false;  
    }  
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);  
}
```
# 226.翻转二叉树
> 交换一棵二叉树的左右结点，适用于前序遍历或后序遍历方式
```java
public TreeNode invertTree(TreeNode root) {  
    if (root == null) {  
        return root;  
    }  
    // 前序遍历方式  
    // 交换左右子结点  
    TreeNode tmp = root.left;  
    root.left = root.right;  
    root.right = tmp;  
    // 翻转左子树（原右子树）  
    invertTree(root.left);  
    // 翻转右子树（原左子树）  
    invertTree(root.right);  
    return root;  
}
```
# 222.完全二叉树的结点个数
> 简单粗暴法，直接遍历二叉树结点并计数
```java
public int countNodes(TreeNode root) {  
    if (root == null) {  
        return 0;  
    }  
    return 1 + countNodes(root.left) + countNodes(root.right);  
}
```
## 题解
> 可以用完全二叉树的特性来减少计算  
> 将完全二叉树分解为满二叉树的组合，满二叉树的结点树是2的N次方减一，N是满二叉树的高度  
> 看一棵树是否是满二叉树，只需要看最左叶子节点的高度是否等于最右叶子节点的高度  
```java
public int countNodes(TreeNode root) {  
    // 完全二叉树由多棵满二叉树组成，满二叉树的结点数为2的N方减一，N为满二叉树的高度  
    // 判断一棵树是否是满二叉树，就看最左叶子节点与最右叶子节点的高度是否一致  
    if (root == null) {  
        return 0;  
    }  
    int maxLeftHeight = 1;  
    int maxRightHeight = 1;  
    // 计算左子树最左叶子节点高度  
    TreeNode left = root.left;  
    while (left != null) {  
        maxLeftHeight++;  
        left = left.left;  
    }  
    // 计算右子树最右叶子节点高度  
    TreeNode right = root.right;  
    while (right != null) {  
        maxRightHeight++;  
        right = right.right;  
    }  
    if (maxLeftHeight == maxRightHeight) {  
        // 乘法，用左移。移位为高度减一  
        return (2 << maxLeftHeight - 1) - 1;  
    }  
    // 非满二叉树，则向下递归拆分为满二叉树计算  
    return 1 + countNodes(root.left) + countNodes(root.right);  
}
```
# 110.平衡二叉树
> 判断一个二叉树是否是平衡二叉树，即任意结点的左右子树高度相差不超过1。高度定义为根结点到叶子结点的最远距离。  
## 题解
> 需要计算左右子树的高度，在计算过程中判断是否是平衡，不平衡则直接返回。因此用-1标识一个子树是非平衡树。
```java
class Solution {  
  
    /**  
     * 获取树的高度并判断平衡，是平衡树时返回树的高度，不是平衡树时直接返回-1  
     */
     public int getHeightAndCheckBalance(TreeNode node) {  
        if (node == null) {  
            return 0;  
        }  
        // 计算左子树高度并判断是否平衡，不平衡直接返回  
        final int l = getHeightAndCheckBalance(node.left);  
        if (l == -1) {  
            return -1;  
        }  
        // 计算右子树高度并判断是否平衡，不平衡直接返回  
        final int r = getHeightAndCheckBalance(node.right);  
        if (r == -1) {  
            return -1;  
        }  
        // 左右子树都是平衡树，则判断两子树的高度是否相差1，是的话则返回当前结点子树高度  
        if (l - r >= -1 && l - r <= 1) {  
            return 1 + Math.max(l, r);  
        }  
        // 否则两子树相差高度超过-1，当前树不是平衡树  
        return -1;  
    }  
  
    public boolean isBalanced(TreeNode root) {  
        return getHeightAndCheckBalance(root) != -1;  
    }  
  
}
```
# 257.二叉树的所有路径
> 给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。
## 题解
> 需要额外记录根节点到当前节点的路径，当每个节点处理完时需要将该节点从路径中移除以便回退到上个节点
```java
class Solution {  
  
    /**  
     * 遍历  
     *  
     * @param node   节点  
     * @param paths  根节点到当前节点路径  
     * @param result 找到的路径集合  
     */  
    public void traverse(TreeNode node, List<TreeNode> paths, List<String> result) {  
        if (node == null || paths.isEmpty()) {  
            return;  
        }  
        // 找到叶子结点，则取出路径放到结果里，路径里移出当前节点  
        if (node.left == null && node.right == null) {  
            result.add(paths.stream().map(p -> p.val).map(String::valueOf).collect(Collectors.joining("->")));  
            paths.removeIf(p -> p == node); // 路径移除当前叶子节点  
            return;  
        }  
        // 遍历左子树  
        if (node.left != null) {  
            paths.add(node.left);  
            traverse(node.left, paths, result);  
        }  
        // 遍历右子树  
        if (node.right != null) {  
            paths.add(node.right);  
            traverse(node.right, paths, result);  
        }  
        // 左右子树处理完，则当前节点已处理完，回退  
        paths.removeIf(p -> p == node); // 路径移除当前结点  
    }  
  
    public List<String> binaryTreePaths(TreeNode root) {  
        List<String> ret = new ArrayList<>();  
        if (root == null) {  
            return ret;  
        }  
        // 从根节点构造入口节点、初始路径开始遍历  
        List<TreeNode> paths = new LinkedList<>();  
        paths.add(root);  
        traverse(root, paths, ret);  
        return ret;  
    }  
}
```
# 404.左叶子之和
> 给定二叉树的根节点 `root` ，返回所有左叶子之和。
## 题解
> 依然是遍历方式，唯一区别是要确定当前遍历节点是左叶子节点
```java
class Solution {  
  
    /**  
     * 计算节点作为左叶子节点时数值  
     */  
    public int calLeftLeaves(TreeNode node, TreeNode parent) {  
        if (node == null || node == parent) {  
            return 0;  
        }  
        // 当前节点在左节点且是叶子节点  
        if (node == parent.left && node.left == null && node.right == null) {  
            return node.val;  
        }  
        return 0;  
    }  
  
    public int sumOfLeftLeaves(TreeNode root) {  
        if (root == null) {  
            return 0;  
        }  
        // 当前左节点有可能为叶子节点，先计算  
        int sum = calLeftLeaves(root.left, root);  
        // 再拼接左子树中左叶子节点之和、右子树中左叶子节点之和  
        return sum + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);  
    }  
}
```
# 112.路径总和
> 给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。
## 题解
> 仍是递归思路，在子树中找到和为剩余值的路径
```java
public boolean hasPathSum(TreeNode root, int targetSum) {  
    if (root == null) {  
        return false;  
    }  
    // 叶子节点，且叶子节点数值符合期望数值  
    if (root.left == null && root.right == null && root.val == targetSum) {  
        return true;  
    }  
    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);  
}
```
# 113.路径总和二
> 给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。
## 题解
> 遍历求和的过程中需要记录找到的路径，处理完的结点需要不断回退
```java
class Solution {  
  
    /**  
     * 查找并记录路径  
     *  
     * @param node      待处理节点  
     * @param targetSum 当前期望节点值  
     * @param paths     遍历节点路径  
     * @param result    符合结果集  
     */  
    public void recordPathSum(TreeNode node, int targetSum, List<TreeNode> paths, List<List<Integer>> result) {  
        if (node == null) {  
            return;  
        }  
        // 叶子节点，路径和满足要求，记录结果，回退  
        if (node.left == null && node.right == null && node.val == targetSum) {  
            result.add(paths.stream().map(p -> p.val).collect(Collectors.toList()));  
            paths.removeIf(p -> p == node);  
            return;  
        }  
        // 向左子树查找  
        if (node.left != null) {  
            paths.add(node.left);  
            recordPathSum(node.left, targetSum - node.val, paths, result);  
        }  
        // 向右子树查找  
        if (node.right != null) {  
            paths.add(node.right);  
            recordPathSum(node.right, targetSum - node.val, paths, result);  
        }  
        // 左右子树处理完，回退  
        paths.removeIf(p -> p == node);  
    }  
  
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {  
        List<List<Integer>> result = new LinkedList<>();  
        if (root == null) {  
            return result;  
        }  
        List<TreeNode> paths = new LinkedList<>();  
        paths.add(root);  
        recordPathSum(root, targetSum, paths, result);  
        return result;  
    }  
}
```
