# 144.二叉树的前序遍历
> 递归方式
```java
public void traversal(TreeNode node, List<Integer> list) {  
    if (node == null) {  
        return;  
    }  
    list.add(node.val); // 处理根节点  
    traversal(node.left, list); // 遍历左子树  
    traversal(node.right, list); // 遍历右子树  
}  
  
public List<Integer> preorderTraversal(TreeNode root) {  
    List<Integer> list = new ArrayList<>();  
    traversal(root, list);  
    return list;  
}
```
> 迭代方式  
```java
public List<Integer> preorderTraversal(TreeNode root) {  
    List<Integer> list = new ArrayList<>();  
    // 用一个栈来记录访问顺序  
    Stack<TreeNode> stack = new Stack<>();  
    stack.push(root); // 先将根结点压入栈中  
    while (!stack.empty()) {  
        final TreeNode node = stack.pop();  
        if (node == null) {  
            continue;  
        }  
        list.add(node.val); // 前序遍历先处理当前结点  
        stack.push(node.right); // 前序遍历先将右孩子结点入栈  
        stack.push(node.left); // 前序遍历再将左孩子结点入栈  
    }  
    return list;  
}
```
# 145.二叉树的后序遍历
> 递归方式
```java
public void traversal(TreeNode node, List<Integer> list) {  
    if (node == null) {  
        return;  
    }  
    traversal(node.left, list); // 遍历左子树  
    traversal(node.right, list); // 遍历右子树  
    list.add(node.val); // 处理根节点  
}  
  
public List<Integer> postorderTraversal(TreeNode root) {  
    List<Integer> list = new ArrayList<>();  
    traversal(root, list);  
    return list;  
}
```
> 迭代方式，采用栈模拟遍历顺序
```java
public List<Integer> postorderTraversal(TreeNode root) {  
    List<Integer> list = new ArrayList<>();  
    if (root == null) {  
        return list;  
    }  
    // 用一个栈来记录访问顺序  
    Stack<TreeNode> stack = new Stack<>();  
    stack.push(root); // 先将根结点压入栈中  
    TreeNode lastPop = null; // 记录上一次栈中弹出元素  
    // 入栈顺序为 根、右、左  
    // 出栈顺序为 左、右、根  
    while (!stack.empty()) {  
        final TreeNode top = stack.peek(); // 栈顶元素  
        // 叶子结点，直接出栈；  
        // 上次出栈为栈顶右孩子节点，则栈顶元素也可以出栈；  
        // 上次出栈为栈顶左孩子结点且栈顶右孩子为空，则栈顶元素可以出栈  
        if ((top.right == null && top.left == null)  
                || (lastPop == top.right && top.right != null)  
                || (lastPop == top.left && top.right == null)) {  
            list.add(top.val);  
            lastPop = stack.pop();  
            continue;        }  
        // 先压入右孩子结点  
        if (top.right != null) {  
            stack.push(top.right);  
        }  
        // 再压入左孩子结点  
        if (top.left != null) {  
            stack.push(top.left);  
        }  
    }  
    return list;  
}
```
# 94.二叉树的中序遍历
> 递归方式
```java
public void traversal(TreeNode node, List<Integer> list) {  
    if (node == null) {  
        return;  
    }  
    traversal(node.left, list); // 遍历左子树  
    list.add(node.val); // 处理根节点  
    traversal(node.right, list); // 遍历右子树  
}  
  
public List<Integer> inorderTraversal(TreeNode root) {  
    List<Integer> list = new ArrayList<>();  
    traversal(root, list);  
    return list;  
}
```
> 迭代方式，用一个指针记录遍历顺序，用栈记录处理顺序  
> 遍历顺序为：根、左、右  
> 处理顺序为：左、根、右  
```java
public List<Integer> inorderTraversal(TreeNode root) {  
    List<Integer> list = new ArrayList<>();  
    // 用一个栈来记录处理顺序  
    Stack<TreeNode> stack = new Stack<>();  
    stack.push(root); // 先将根结点压入栈中  
    TreeNode curr = root; // 遍历指针  
    while (curr != null && !stack.empty()) {  
        // 左孩子不为空，则左孩子入栈，并继续遍历左孩子  
        if (curr.left != null) {  
            stack.push(curr.left);  
            curr = curr.left;  
        } else {  
            // 左孩子为空，添加当前结点  
            TreeNode node = stack.pop();  
            list.add(node.val);  
            // 右孩子不为空，则遍历右孩子  
            if (node.right != null) {  
                stack.push(node.right);  
                curr = node.right;  
            }  
        }  
    }  
    return list;  
}
```
# 102.二叉树的层序遍历
> 用一个队列来保存每一层的结点。每处理完一个结点，则将其左右孩子结点加入到队列  
> 关键点是记录每层结点数量  
```java
public List<List<Integer>> levelOrder(TreeNode root) {  
    // 采用队列记录每层的结点数  
    Queue<TreeNode> queue = new LinkedList<>();  
    int levelSize = 0;  
    List<List<Integer>> ret = new ArrayList<>();  
    queue.add(root);  
    levelSize = 1; // 当前需要遍历的层的结点总数  
    while (!queue.isEmpty()) {  
        List<Integer> levelNodes = new ArrayList<>();  
        for (int i = 0; i < levelSize; i++) {  
            final TreeNode node = queue.poll();  
            if (node == null) {  
                continue;  
            }  
            levelNodes.add(node.val); // 获取层结点  
            queue.add(node.left); // 将该结点的下层左孩子结点添加到队列  
            queue.add(node.right); // 将该结点的下层右孩子结点添加到队列  
        }  
        if (levelNodes.size() > 0) {  
            ret.add(levelNodes);  
        }  
        levelSize = queue.size(); // 关键！当前队列中元素为下层所有结点  
    }  
    return ret;  
}
```
# 107.二叉树的层序遍历二
> 给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）  
## 题解
> 要求是自底向上，所以在自顶向下额基础上把结果翻转下即可 
```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {  
    List<List<Integer>> ret = new ArrayList<>();  
    if (root == null) {  
        return ret;  
    }  
    Queue<TreeNode> queue = new LinkedList<>();  
    queue.add(root);  
    int levelSize = 1;  
    while (!queue.isEmpty()) {  
        List<Integer> levelNodes = new ArrayList<>();  
        for (int i = 0; i < levelSize; i++) {  
            final TreeNode node = queue.poll();  
            levelNodes.add(node.val);  
            if (node.left != null) {  
                queue.add(node.left);  
            }  
            if (node.right != null) {  
                queue.add(node.right);  
            }  
        }  
        if (!levelNodes.isEmpty()) {  
            ret.add(levelNodes);  
        }  
        levelSize = queue.size();  
    }  
    // 翻转  
    Collections.reverse(ret);  
    return ret;  
}
```
# 199.二叉树的右视图
> 给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。  
## 题解
> 二叉树层序遍历输出每一层的最后一个结点
```java
public List<Integer> rightSideView(TreeNode root) {  
    List<Integer> ret = new ArrayList<>();  
    if (root == null) {  
        return ret;  
    }  
    Queue<TreeNode> queue = new LinkedList<>();  
    queue.add(root);  
    int levelSize = 1;  
    while (!queue.isEmpty()) {  
        for (int i = 0; i < levelSize; i++) {  
            TreeNode node = queue.poll();  
            // 每一层的最后一个结点输出  
            if (i == levelSize - 1) {  
                ret.add(node.val);  
            }  
            if (node.left != null) {  
                queue.add(node.left);  
            }  
            if (node.right != null) {  
                queue.add(node.right);  
            }  
        }  
        levelSize = queue.size();  
    }  
    return ret;  
}
```
# 429.N叉树的层序遍历
> 二叉树层序遍历的延伸
```java
public List<List<Integer>> levelOrder(Node root) {  
    List<List<Integer>> ret = new ArrayList<>();  
    if (root == null) {  
        return ret;  
    }  
    Queue<Node> queue = new LinkedList<>();  
    queue.add(root);  
    int levelSize = 1;  
    while (!queue.isEmpty()) {  
        List<Integer> levelNodes = new ArrayList<>();  
        for (int i = 0; i < levelSize; i++) {  
            final Node node = queue.poll();  
            levelNodes.add(node.val);  
            if (node.children != null) {  
                for (Node n : node.children) {  
                    if (n != null) {  
                        queue.add(n);  
                    }  
                }  
            }  
        }  
        if (!levelNodes.isEmpty()) {  
            ret.add(levelNodes);  
        }  
        levelSize = queue.size();  
    }  
    return ret;  
}
```
# 116.填充每个结点的下一个右侧指针结点
> 每一层的结点从左到右连起来组成链表  
> 层序遍历的应用场景之一，获取到层序结点时连接起来  
```java
public Node connect(Node root) {  
    if (root == null) {  
        return root;  
    }  
    Queue<Node> queue = new LinkedList<>();  
    queue.add(root);  
    int levelSize = 1;  
    while (!queue.isEmpty()) {  
        for (int i = 0; i < levelSize; i++) {  
            Node node = queue.poll();  
            if (i < levelSize - 1) {  
                node.next = queue.peek();  
            }  
            if (node.left != null) {  
                queue.add(node.left);  
            }  
            if (node.right != null) {  
                queue.add(node.right);  
            }  
        }  
        levelSize = queue.size();  
    }  
    return root;  
}
```
# 104.二叉树的最大深度
> 深度为根节点到该结点的距离  
```java
public int maxDepth(TreeNode root) {  
    if (root == null) {  
        return 0;  
    }  
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));  
}
```
# 111.二叉树的最小深度
> 计算根节点到叶子结点(叶子节点是指没有子节点的节点)的最短路径长度  
```java
public int minDepth(TreeNode root) {  
    if (root == null) {  
        return 0;  
    }  
    if (root.left == null && root.right == null) {  
        return 1;  
    } else if (root.left == null) {  
        return 1 + minDepth(root.right);  
    } else if (root.right == null) {  
        return 1 + minDepth(root.left);  
    } else {  
        return 1 + Math.min(minDepth(root.left), minDepth(root.right));  
    }  
}
```
# 100.相同的树
> 判断两个树有相同的结构且在相同的位置上有相同的节点值
```java
public boolean isSameTree(TreeNode p, TreeNode q) {  
    if (p == q) {  
        return true;  
    }  
    if ((p == null && q != null)  
            || (p != null && q == null)  
            || (p.val != q.val)) {  
        return false;  
    }  
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);  
}
```
# 226.翻转二叉树
> 交换一棵二叉树的左右结点，适用于前序遍历或后序遍历方式
```java
public TreeNode invertTree(TreeNode root) {  
    if (root == null) {  
        return root;  
    }  
    // 前序遍历方式  
    // 交换左右子结点  
    TreeNode tmp = root.left;  
    root.left = root.right;  
    root.right = tmp;  
    // 翻转左子树（原右子树）  
    invertTree(root.left);  
    // 翻转右子树（原左子树）  
    invertTree(root.right);  
    return root;  
}
```
# 222.完全二叉树的结点个数
> 简单粗暴法，直接遍历二叉树结点并计数
```java
public int countNodes(TreeNode root) {  
    if (root == null) {  
        return 0;  
    }  
    return 1 + countNodes(root.left) + countNodes(root.right);  
}
```
# 110.平衡二叉树
> 判断一个二叉树是否是平衡二叉树，即任意结点的左右子树高度相差不超过1。高度定义为根结点到叶子结点的最远距离。  
## 题解
> 需要计算左右子树的高度，在计算过程中判断是否是平衡，不平衡则直接返回。因此用-1标识一个子树是非平衡树。
```java
class Solution {  
  
    /**  
     * 获取树的高度并判断平衡，是平衡树时返回树的高度，不是平衡树时直接返回-1  
     */
     public int getHeightAndCheckBalance(TreeNode node) {  
        if (node == null) {  
            return 0;  
        }  
        // 计算左子树高度并判断是否平衡，不平衡直接返回  
        final int l = getHeightAndCheckBalance(node.left);  
        if (l == -1) {  
            return -1;  
        }  
        // 计算右子树高度并判断是否平衡，不平衡直接返回  
        final int r = getHeightAndCheckBalance(node.right);  
        if (r == -1) {  
            return -1;  
        }  
        // 左右子树都是平衡树，则判断两子树的高度是否相差1，是的话则返回当前结点子树高度  
        if (l - r >= -1 && l - r <= 1) {  
            return 1 + Math.max(l, r);  
        }  
        // 否则两子树相差高度超过-1，当前树不是平衡树  
        return -1;  
    }  
  
    public boolean isBalanced(TreeNode root) {  
        return getHeightAndCheckBalance(root) != -1;  
    }  
  
}
```
# 257.二叉树的所有路径
> 给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。
## 题解
> 需要额外记录根节点到当前节点的路径，当每个节点处理完时需要将该节点从路径中移除以便回退到上个节点
```java
class Solution {  
  
    /**  
     * 遍历  
     *  
     * @param node   节点  
     * @param paths  根节点到当前节点路径  
     * @param result 找到的路径集合  
     */  
    public void traverse(TreeNode node, List<TreeNode> paths, List<String> result) {  
        if (node == null || paths.isEmpty()) {  
            return;  
        }  
        // 找到叶子结点，则取出路径放到结果里，路径里移出当前节点  
        if (node.left == null && node.right == null) {  
            result.add(paths.stream().map(p -> p.val).map(String::valueOf).collect(Collectors.joining("->")));  
            paths.removeIf(p -> p == node); // 路径移除当前叶子节点  
            return;  
        }  
        // 遍历左子树  
        if (node.left != null) {  
            paths.add(node.left);  
            traverse(node.left, paths, result);  
        }  
        // 遍历右子树  
        if (node.right != null) {  
            paths.add(node.right);  
            traverse(node.right, paths, result);  
        }  
        // 左右子树处理完，则当前节点已处理完，回退  
        paths.removeIf(p -> p == node); // 路径移除当前结点  
    }  
  
    public List<String> binaryTreePaths(TreeNode root) {  
        List<String> ret = new ArrayList<>();  
        if (root == null) {  
            return ret;  
        }  
        // 从根节点构造入口节点、初始路径开始遍历  
        List<TreeNode> paths = new LinkedList<>();  
        paths.add(root);  
        traverse(root, paths, ret);  
        return ret;  
    }  
}
```
# 404.左叶子之和
> 给定二叉树的根节点 `root` ，返回所有左叶子之和。
## 题解
> 依然是遍历方式，唯一区别是要确定当前遍历节点是左叶子节点
```java
class Solution {  
  
    /**  
     * 计算节点作为左叶子节点时数值  
     */  
    public int calLeftLeaves(TreeNode node, TreeNode parent) {  
        if (node == null || node == parent) {  
            return 0;  
        }  
        // 当前节点在左节点且是叶子节点  
        if (node == parent.left && node.left == null && node.right == null) {  
            return node.val;  
        }  
        return 0;  
    }  
  
    public int sumOfLeftLeaves(TreeNode root) {  
        if (root == null) {  
            return 0;  
        }  
        // 当前左节点有可能为叶子节点，先计算  
        int sum = calLeftLeaves(root.left, root);  
        // 再拼接左子树中左叶子节点之和、右子树中左叶子节点之和  
        return sum + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);  
    }  
}
```
# 112.路径总和
> 给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。
## 题解
> 仍是递归思路，在子树中找到和为剩余值的路径
```java
public boolean hasPathSum(TreeNode root, int targetSum) {  
    if (root == null) {  
        return false;  
    }  
    // 叶子节点，且叶子节点数值符合期望数值  
    if (root.left == null && root.right == null && root.val == targetSum) {  
        return true;  
    }  
    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);  
}
```
# 113.路径总和二
> 给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。
## 题解
> 遍历求和的过程中需要记录找到的路径，处理完的结点需要不断回退
```java
class Solution {  
  
    /**  
     * 查找并记录路径  
     *  
     * @param node      待处理节点  
     * @param targetSum 当前期望节点值  
     * @param paths     遍历节点路径  
     * @param result    符合结果集  
     */  
    public void recordPathSum(TreeNode node, int targetSum, List<TreeNode> paths, List<List<Integer>> result) {  
        if (node == null) {  
            return;  
        }  
        // 叶子节点，路径和满足要求，记录结果，回退  
        if (node.left == null && node.right == null && node.val == targetSum) {  
            result.add(paths.stream().map(p -> p.val).collect(Collectors.toList()));  
            paths.removeIf(p -> p == node);  
            return;  
        }  
        // 向左子树查找  
        if (node.left != null) {  
            paths.add(node.left);  
            recordPathSum(node.left, targetSum - node.val, paths, result);  
        }  
        // 向右子树查找  
        if (node.right != null) {  
            paths.add(node.right);  
            recordPathSum(node.right, targetSum - node.val, paths, result);  
        }  
        // 左右子树处理完，回退  
        paths.removeIf(p -> p == node);  
    }  
  
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {  
        List<List<Integer>> result = new LinkedList<>();  
        if (root == null) {  
            return result;  
        }  
        List<TreeNode> paths = new LinkedList<>();  
        paths.add(root);  
        recordPathSum(root, targetSum, paths, result);  
        return result;  
    }  
}
```
# 106.从中序与后序遍历序列构造二叉树
> 给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 _二叉树_ 。
## 题解
> 核心思想是采用递归方式构建  
> 后序遍历序列的末尾是根节点  
> 根据根节点先切割中序遍历序列，得到左右子树的中序遍历序列  
> 根据左右子树的中序遍历序列得到左右子树的长度，可以到后序遍历序列中切割出左右子树的后序遍历序列  
> 采用递归方式构建左右子树  
```java
public TreeNode buildTree(int[] inorder, int[] postorder) {  
    // 递归结束条件：遍历结果为空，表示无任何结点  
    if (inorder.length == 0) {  
        return null;  
    }  
    // 根节点为后序遍历数组的最后一个  
    int rootVal = postorder[postorder.length - 1];  
    TreeNode root = new TreeNode(rootVal);  
    // 找到根节点之后从根节点切割中序数组，左边为左子树，右边为右子树  
    int i = 0; // 定义为根节点所在数组下标  
    for (; i < inorder.length; i++) {  
        if (inorder[i] == rootVal) {  
            break;  
        }  
    }  
    // 左子树的中序遍历数组为inorder[0,i-1];  
    int[] leftInOrder = new int[i];  
    System.arraycopy(inorder, 0, leftInOrder, 0, i);  
    // 右子树的中序遍历数组为inorder[i+1,inorder.length-1]  
    int[] rightInOrder = new int[inorder.length - i - 1];  
    System.arraycopy(inorder, i + 1, rightInOrder, 0, inorder.length - i - 1);  
    // 切割后序数组，切割出左右子树对应的后序数组  
    // 后序数组最后一位是根节点，无需处理  
    // 左子树的后序遍历数组为postorder[0,leftInOrder.length-1],长度与左子树中序数组一样  
    int[] leftPostOrder = new int[leftInOrder.length];  
    System.arraycopy(postorder, 0, leftPostOrder, 0, leftInOrder.length);  
    // 右子树的后序遍历数组为postorder[leftInOrder.length,postorder.length-2],长度与右子树中序数组一样  
    int[] rightPostOrder = new int[rightInOrder.length];  
    System.arraycopy(postorder, leftInOrder.length, rightPostOrder, 0, rightInOrder.length);  
    // 递归处理左子树  
    root.left = buildTree(leftInOrder, leftPostOrder);  
    // 递归处理右子树  
    root.right = buildTree(rightInOrder, rightPostOrder);  
    return root;  
}
```
# 105.从前序与中序遍历序列构建二叉树
> 参考106
```java
public TreeNode buildTree(int[] preorder, int[] inorder) {  
    if (preorder.length == 0) {  
        return null;  
    }  
    // 根节点为前序序列的首位  
    TreeNode root = new TreeNode(preorder[0]);  
    int i = 0; // 根节点在中序序列中的下标  
    for (; i < inorder.length; i++) {  
        if (inorder[i] == preorder[0]) {  
            break;  
        }  
    }  
    // 切割左右子树的中序序列  
    int[] leftInOrder = new int[i];  
    System.arraycopy(inorder, 0, leftInOrder, 0, i);  
    int[] rightInOrder = new int[inorder.length - i - 1];  
    System.arraycopy(inorder, i + 1, rightInOrder, 0, inorder.length - i - 1);  
    // 切割左右子树的前序序列  
    int[] leftPreorder = new int[leftInOrder.length];  
    System.arraycopy(preorder, 1, leftPreorder, 0, leftPreorder.length);  
    int[] rightPreorder = new int[rightInOrder.length];  
    System.arraycopy(preorder, leftPreorder.length + 1, rightPreorder, 0, rightPreorder.length);  
    // 递归构建左子树  
    root.left = buildTree(leftPreorder, leftInOrder);  
    // 递归构建右子树  
    root.right = buildTree(rightPreorder, rightInOrder);  
    return root;  
}
```