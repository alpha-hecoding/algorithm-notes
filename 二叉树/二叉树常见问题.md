# 106.从中序与后序遍历序列构造二叉树
> 给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 _二叉树_ 。
## 题解
> 核心思想是采用递归方式构建  
> 后序遍历序列的末尾是根节点  
> 根据根节点先切割中序遍历序列，得到左右子树的中序遍历序列  
> 根据左右子树的中序遍历序列得到左右子树的长度，可以到后序遍历序列中切割出左右子树的后序遍历序列  
> 采用递归方式构建左右子树  
```java
public TreeNode buildTree(int[] inorder, int[] postorder) {  
    // 递归结束条件：遍历结果为空，表示无任何结点  
    if (inorder.length == 0) {  
        return null;  
    }  
    // 根节点为后序遍历数组的最后一个  
    int rootVal = postorder[postorder.length - 1];  
    TreeNode root = new TreeNode(rootVal);  
    // 找到根节点之后从根节点切割中序数组，左边为左子树，右边为右子树  
    int i = 0; // 定义为根节点所在数组下标  
    for (; i < inorder.length; i++) {  
        if (inorder[i] == rootVal) {  
            break;  
        }  
    }  
    // 左子树的中序遍历数组为inorder[0,i-1];  
    int[] leftInOrder = new int[i];  
    System.arraycopy(inorder, 0, leftInOrder, 0, i);  
    // 右子树的中序遍历数组为inorder[i+1,inorder.length-1]  
    int[] rightInOrder = new int[inorder.length - i - 1];  
    System.arraycopy(inorder, i + 1, rightInOrder, 0, inorder.length - i - 1);  
    // 切割后序数组，切割出左右子树对应的后序数组  
    // 后序数组最后一位是根节点，无需处理  
    // 左子树的后序遍历数组为postorder[0,leftInOrder.length-1],长度与左子树中序数组一样  
    int[] leftPostOrder = new int[leftInOrder.length];  
    System.arraycopy(postorder, 0, leftPostOrder, 0, leftInOrder.length);  
    // 右子树的后序遍历数组为postorder[leftInOrder.length,postorder.length-2],长度与右子树中序数组一样  
    int[] rightPostOrder = new int[rightInOrder.length];  
    System.arraycopy(postorder, leftInOrder.length, rightPostOrder, 0, rightInOrder.length);  
    // 递归处理左子树  
    root.left = buildTree(leftInOrder, leftPostOrder);  
    // 递归处理右子树  
    root.right = buildTree(rightInOrder, rightPostOrder);  
    return root;  
}
```
# 105.从前序与中序遍历序列构建二叉树
> 参考106
```java
public TreeNode buildTree(int[] preorder, int[] inorder) {  
    if (preorder.length == 0) {  
        return null;  
    }  
    // 根节点为前序序列的首位  
    TreeNode root = new TreeNode(preorder[0]);  
    int i = 0; // 根节点在中序序列中的下标  
    for (; i < inorder.length; i++) {  
        if (inorder[i] == preorder[0]) {  
            break;  
        }  
    }  
    // 切割左右子树的中序序列  
    int[] leftInOrder = new int[i];  
    System.arraycopy(inorder, 0, leftInOrder, 0, i);  
    int[] rightInOrder = new int[inorder.length - i - 1];  
    System.arraycopy(inorder, i + 1, rightInOrder, 0, inorder.length - i - 1);  
    // 切割左右子树的前序序列  
    int[] leftPreorder = new int[leftInOrder.length];  
    System.arraycopy(preorder, 1, leftPreorder, 0, leftPreorder.length);  
    int[] rightPreorder = new int[rightInOrder.length];  
    System.arraycopy(preorder, leftPreorder.length + 1, rightPreorder, 0, rightPreorder.length);  
    // 递归构建左子树  
    root.left = buildTree(leftPreorder, leftInOrder);  
    // 递归构建右子树  
    root.right = buildTree(rightPreorder, rightInOrder);  
    return root;  
}
```
# 654.最大二叉树
给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:

1. 创建一个根节点，其值为 `nums` 中的最大值。
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。
## 题解
> 拆分左右子树节点递归构建
```java
public TreeNode constructMaximumBinaryTree(int[] nums) {  
    if (nums.length == 0) {  
        return null;  
    }  
    int k = 0; // 最大值下标  
    for (int i = 1; i < nums.length; i++) {  
        if (nums[i] > nums[k]) {  
            k = i;  
        }  
    }  
    TreeNode root = new TreeNode(nums[k]);  
    // 构建左子树  
    int[] leftNums = new int[k];  
    System.arraycopy(nums, 0, leftNums, 0, k);  
    root.left = constructMaximumBinaryTree(leftNums);  
    // 构建右子树  
    int[] rightNums = new int[nums.length - k - 1];  
    System.arraycopy(nums, k + 1, rightNums, 0, nums.length - k - 1);  
    root.right = constructMaximumBinaryTree(rightNums);  
    return root;  
}
```
# 617.合并二叉树
给你两棵二叉树： `root1` 和 `root2` 。  

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。  
返回合并后的二叉树。  
## 题解
> 采用前序遍历方式，先合并根节点，再依次递归合并左子树、右子树
```java
public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {  
    TreeNode root = null;  
    if (root1 == null && root2 == null) {  
        return null;  
    } else if (root1 != null && root2 == null) {  
        root = root1;  
    } else if (root1 == null && root2 != null) {  
        root = root2;  
    } else {  
        root = new TreeNode(root1.val + root2.val);  
    }  
    root.left = mergeTrees(root1 != null ? root1.left : null, root2 != null ? root2.left : null);  
    root.right = mergeTrees(root1 != null ? root1.right : null, root2 != null ? root2.right : null);  
    return root;  
}
```
