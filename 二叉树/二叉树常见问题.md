# 给定层序完全遍历结果构造二叉树
> 示例: [3,5,1,6,2,0,8,null,null,7,4]
![](../asset/二叉树示例.png)
```java
public static class TreeNode {  
    int val;  
    TreeNode left;  
    TreeNode right;  
  
    TreeNode(int x) {  
        val = x;  
    }  
  
    public static TreeNode of(Integer val) {  
        return val == null ? null : new TreeNode(val);  
    }  
}  
  
public static TreeNode buildTree(List<Integer> valList) {  
    TreeNode root = TreeNode.of(valList.get(0));  
    Map<Integer, List<TreeNode>> levelMap = new HashMap<>();  
    int level = 1; // 层数，从1开始  
    levelMap.computeIfAbsent(level, k -> new ArrayList<>()).add(root);  
    // 每层最左节点下标为 (1 << level - 1) - 1，该层最大元素个数为 1 << level - 1    final int maxIndex = valList.size() - 1;  
    while (true) {  
        int indexStart = (1 << level) - 1; // 从第二层开始构建第一层的子节点 
        if (indexStart > maxIndex) {  
            break;  
        }  
        final List<TreeNode> treeNodes = levelMap.get(level);  
        for (int i = 0; i < treeNodes.size(); i++) {  
            final TreeNode node = treeNodes.get(i);  
            if (node == null) {  
                continue;  
            }  
            int leftIndex = indexStart + i * 2; // 左子树的下标  
            int rightIndex = indexStart + i * 2 + 1; // 右子树的下标  
            if (leftIndex <= maxIndex) {  
                node.left = TreeNode.of(valList.get(leftIndex));  
                levelMap.computeIfAbsent(level + 1, k -> new ArrayList<>()).add(node.left);  
            } else {  
                break;  
            }  
            if (rightIndex <= maxIndex) {  
                node.right = TreeNode.of(valList.get(rightIndex));  
                levelMap.computeIfAbsent(level + 1, k -> new ArrayList<>()).add(node.right);  
            } else {  
                break;  
            }  
        }  
        level++;  
    }  
    System.out.println(levelMap);  
    return root;  
}
```
# 106.从中序与后序遍历序列构造二叉树
> 给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 _二叉树_ 。
## 题解
> 核心思想是采用递归方式构建  
> 后序遍历序列的末尾是根节点  
> 根据根节点先切割中序遍历序列，得到左右子树的中序遍历序列  
> 根据左右子树的中序遍历序列得到左右子树的长度，可以到后序遍历序列中切割出左右子树的后序遍历序列  
> 采用递归方式构建左右子树  
```java
public TreeNode buildTree(int[] inorder, int[] postorder) {  
    // 递归结束条件：遍历结果为空，表示无任何结点  
    if (inorder.length == 0) {  
        return null;  
    }  
    // 根节点为后序遍历数组的最后一个  
    int rootVal = postorder[postorder.length - 1];  
    TreeNode root = new TreeNode(rootVal);  
    // 找到根节点之后从根节点切割中序数组，左边为左子树，右边为右子树  
    int i = 0; // 定义为根节点所在数组下标  
    for (; i < inorder.length; i++) {  
        if (inorder[i] == rootVal) {  
            break;  
        }  
    }  
    // 左子树的中序遍历数组为inorder[0,i-1];  
    int[] leftInOrder = new int[i];  
    System.arraycopy(inorder, 0, leftInOrder, 0, i);  
    // 右子树的中序遍历数组为inorder[i+1,inorder.length-1]  
    int[] rightInOrder = new int[inorder.length - i - 1];  
    System.arraycopy(inorder, i + 1, rightInOrder, 0, inorder.length - i - 1);  
    // 切割后序数组，切割出左右子树对应的后序数组  
    // 后序数组最后一位是根节点，无需处理  
    // 左子树的后序遍历数组为postorder[0,leftInOrder.length-1],长度与左子树中序数组一样  
    int[] leftPostOrder = new int[leftInOrder.length];  
    System.arraycopy(postorder, 0, leftPostOrder, 0, leftInOrder.length);  
    // 右子树的后序遍历数组为postorder[leftInOrder.length,postorder.length-2],长度与右子树中序数组一样  
    int[] rightPostOrder = new int[rightInOrder.length];  
    System.arraycopy(postorder, leftInOrder.length, rightPostOrder, 0, rightInOrder.length);  
    // 递归处理左子树  
    root.left = buildTree(leftInOrder, leftPostOrder);  
    // 递归处理右子树  
    root.right = buildTree(rightInOrder, rightPostOrder);  
    return root;  
}
```
# 105.从前序与中序遍历序列构建二叉树
> 参考106
```java
public TreeNode buildTree(int[] preorder, int[] inorder) {  
    if (preorder.length == 0) {  
        return null;  
    }  
    // 根节点为前序序列的首位  
    TreeNode root = new TreeNode(preorder[0]);  
    int i = 0; // 根节点在中序序列中的下标  
    for (; i < inorder.length; i++) {  
        if (inorder[i] == preorder[0]) {  
            break;  
        }  
    }  
    // 切割左右子树的中序序列  
    int[] leftInOrder = new int[i];  
    System.arraycopy(inorder, 0, leftInOrder, 0, i);  
    int[] rightInOrder = new int[inorder.length - i - 1];  
    System.arraycopy(inorder, i + 1, rightInOrder, 0, inorder.length - i - 1);  
    // 切割左右子树的前序序列  
    int[] leftPreorder = new int[leftInOrder.length];  
    System.arraycopy(preorder, 1, leftPreorder, 0, leftPreorder.length);  
    int[] rightPreorder = new int[rightInOrder.length];  
    System.arraycopy(preorder, leftPreorder.length + 1, rightPreorder, 0, rightPreorder.length);  
    // 递归构建左子树  
    root.left = buildTree(leftPreorder, leftInOrder);  
    // 递归构建右子树  
    root.right = buildTree(rightPreorder, rightInOrder);  
    return root;  
}
```
# 654.最大二叉树
给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:

1. 创建一个根节点，其值为 `nums` 中的最大值。
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。
## 题解
> 拆分左右子树节点递归构建
```java
public TreeNode constructMaximumBinaryTree(int[] nums) {  
    if (nums.length == 0) {  
        return null;  
    }  
    int k = 0; // 最大值下标  
    for (int i = 1; i < nums.length; i++) {  
        if (nums[i] > nums[k]) {  
            k = i;  
        }  
    }  
    TreeNode root = new TreeNode(nums[k]);  
    // 构建左子树  
    int[] leftNums = new int[k];  
    System.arraycopy(nums, 0, leftNums, 0, k);  
    root.left = constructMaximumBinaryTree(leftNums);  
    // 构建右子树  
    int[] rightNums = new int[nums.length - k - 1];  
    System.arraycopy(nums, k + 1, rightNums, 0, nums.length - k - 1);  
    root.right = constructMaximumBinaryTree(rightNums);  
    return root;  
}
```
# 617.合并二叉树
给你两棵二叉树： `root1` 和 `root2` 。  

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。  
返回合并后的二叉树。  
## 题解
> 采用前序遍历方式，先合并根节点，再依次递归合并左子树、右子树
```java
public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {  
    TreeNode root = null;  
    if (root1 == null && root2 == null) {  
        return null;  
    } else if (root1 != null && root2 == null) {  
        root = root1;  
    } else if (root1 == null && root2 != null) {  
        root = root2;  
    } else {  
        root = new TreeNode(root1.val + root2.val);  
    }  
    root.left = mergeTrees(root1 != null ? root1.left : null, root2 != null ? root2.left : null);  
    root.right = mergeTrees(root1 != null ? root1.right : null, root2 != null ? root2.right : null);  
    return root;  
}
```
# 236.二叉树的最近公共祖先
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”
## 题解
> 找到从根节点到两个节点的路径，类似于有相同头结点的两条链表，寻找它们开始分叉的地方  
```java
class Solution {  
  
    public boolean findPath(TreeNode root, TreeNode target, Deque<TreeNode> paths) {  
        if (root == null) {  
            return false; // 遇到叶子节点停止搜索  
        } else if (root == target) {  
            paths.addLast(root); // 找到目标节点，停止搜索  
            return true;  
        }  
        // 未找到，则将节点加入到路径  
        paths.addLast(root);  
        final boolean inLeft = findPath(root.left, target, paths);  
        if (inLeft) {  
            return true;  
        }  
        final boolean inRight = findPath(root.right, target, paths);  
        if (inRight) {  
            return true;  
        }  
        // 仍未找到，则将节点从路径移除  
        paths.removeLast();  
        return false;  
    }  
  
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {  
        Deque<TreeNode> path1 = new LinkedList<>();  
        Deque<TreeNode> path2 = new LinkedList<>();  
        findPath(root, p, path1); // 查找节点p的路径  
        findPath(root, q, path2); // 查找节点q的路径  
        int i = 0;  
        TreeNode pre = null;  
        TreeNode curr1 = path1.pollFirst();  
        TreeNode curr2 = path2.pollFirst();  
        while (curr1 == curr2 && curr1 != null) {  
            pre = curr1;  
            curr1 = path1.pollFirst();  
            curr2 = path2.pollFirst();  
        }  
        return pre;  
    }  
}
```
## 回溯思路
> 遍历过程中找到目标节点即返回，返回后判断节点若是分布在两棵子树还是分布是其中一棵子树上  
> **如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先**
```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {  
    if (root == null || root == p || root == q) {  
        // 为空节点直接返回  
        // 为目标节点直接返回目标节点，相当于将该节点上移  
        return root;  
    }  
    // 从左子树中找到最近公共祖先  
    TreeNode left = lowestCommonAncestor(root.left, p, q);  
    // 从右子树中找到最近公共祖先  
    TreeNode right = lowestCommonAncestor(root.right, p, q);  
    if (left != null && right != null) {  
        return root; // 左右子树分别找到p、q中的一个，root为公共节点  
    } else if (left != null) {  
        return left; // 左子树不为空且右子树为空，p、q都在左子树，递归首次遇到p、q节点即返回，也是公共节点  
    } else if (right != null) {  
        return right; // 右子树不为空且左子树为空，p、q都在右子树，递归首次遇到p、q节点即返回，也是公共节点  
    } else {  
        return null; // 左右子树都返回为空，说明该子树所有递归路径中不含p、q节点  
    }  
}
```
