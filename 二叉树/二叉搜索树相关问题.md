# 700.二叉搜索树中的搜索
给定二叉搜索树（BST）的根节点 `root` 和一个整数值 `val`。

你需要在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null` 。
## 题解
> 类似于二分查找，递归方式
```java
public TreeNode searchBST(TreeNode root, int val) {  
    if (root == null) {  
        return null;  
    } else if (root.val == val) {  
        return root;  
    } else if (root.val < val) {  
        return searchBST(root.right, val);  
    } else {  
        return searchBST(root.left, val);  
    }  
}
```
# 98.判断是否是二叉搜索树
> 左子树所有节点值小于根节点值  
> 右子树所有节点值大于根节点值  
> 递归的过程中要动态更新节点的上下限  
```java
/**  
 * 判断是否是二叉搜索树  
 *  
 * @param root  节点  
 * @param lower 下限  
 * @param upper 上限  
 */  
boolean validBST(TreeNode root, long lower, long upper) {  
    if (root == null) {  
        return true;  
    }  
    if (root.val <= lower || root.val >= upper) {  
        return false;  
    }  
    // 每次递归用当前节点的上下限进一步限制左右子树的上下限  
    // 左子树下限不能低于当前节点的上限，上限不能超过当前节点值  
    // 右子树下限不能低于当前节点值，上限不能超过当前节点的上限  
    return validBST(root.left, lower, root.val) && validBST(root.right, root.val, upper);  
}  
  
public boolean isValidBST(TreeNode root) {  
    return validBST(root, Long.MIN_VALUE, Long.MAX_VALUE);  
}
```
> 另一种思路是将二叉树按中序遍历结果展开为数组，判断数组是否是有序的  
# 530.二叉搜索树的最小绝对差
> 给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。
## 题解
> 二叉搜索树的中序遍历结果是有序的，因此先进行中序遍历，再依次计算相邻位置上元素之差，取最小即可  
```java
/**  
 * 中序遍历并保存结果  
 */  
public void middleTraversal(TreeNode node, List<Integer> list) {  
    if (node == null) {  
        return;  
    }  
    middleTraversal(node.left, list);  
    list.add(node.val);  
    middleTraversal(node.right, list);  
}  
  
public int getMinimumDifference(TreeNode root) {  
    List<Integer> list = new ArrayList<>();  
    middleTraversal(root, list);  
    int min = Integer.MAX_VALUE;  
    for (int i = 1; i < list.size(); i++) {  
        min = Integer.min(min, Math.abs(list.get(i) - list.get(i - 1)));  
    }  
    return min;  
}
```
# 501.二叉搜索树中的众数
> 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。  
> 左孩子结点小于等于根节点，右孩子结点大于等于根节点  
# 题解
> 中序遍历后得到有序的数组，相同数值排列在一起，可以用双指针法计算相同数值的个数;；   
> 也可以在遍历过程中比较前一个节点与当前节点值，动态统计相同值结点数并收集结果；  
```java
class Solution {  
  
    private TreeNode pre;  
    private List<Integer> result = new ArrayList<>();  
    private int maxCount;  
    private int count;  
  
    public void traversal(TreeNode node) {  
        if (node == null) {  
            return;  
        }  
  
        // 遍历左子树  
        traversal(node.left);  
  
        // 处理中节点  
        // 遍历的前一个节点为空（根节点），初始计数  
        if (pre == null) {  
            count = 1;  
        } else if (node.val != pre.val) {  
            // 当前节点值不等于前一个节点值，重置计数  
            count = 1;  
        } else {  
            // 当前节点值与遍历前一个节点值相等，计数更新  
            count++;  
        }  
        // 计数值处理  
        if (count == maxCount) {  
            // 达到当前最大计数，添加到结果集中  
            result.add(node.val);  
        } else if (count > maxCount) {  
            // 超过当前最大计数，清空结果集，更新结果集并更新最大计数  
            result.clear();  
            result.add(node.val);  
            maxCount = count;  
        }  
        // 中节点处理完，更新遍历前节点指针  
        pre = node;  
  
        // 遍历右子树  
        traversal(node.right);  
    }  
  
    public int[] findMode(TreeNode root) {  
        traversal(root);  
        int[] ret = new int[result.size()];  
        for (int i = 0; i < result.size(); i++) {  
            ret[i] = result.get(i);  
        }  
        return ret;  
    }  
}
```
