# 700.二叉搜索树中的搜索
给定二叉搜索树（BST）的根节点 `root` 和一个整数值 `val`。

你需要在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null` 。
## 题解
> 类似于二分查找，递归方式
```java
public TreeNode searchBST(TreeNode root, int val) {  
    if (root == null) {  
        return null;  
    } else if (root.val == val) {  
        return root;  
    } else if (root.val < val) {  
        return searchBST(root.right, val);  
    } else {  
        return searchBST(root.left, val);  
    }  
}
```
# 98.判断是否是二叉搜索树
> 左子树所有节点值小于根节点值  
> 右子树所有节点值大于根节点值  
> 递归的过程中要动态更新节点的上下限  
```java
/**  
 * 判断是否是二叉搜索树  
 *  
 * @param root  节点  
 * @param lower 下限  
 * @param upper 上限  
 */  
boolean validBST(TreeNode root, long lower, long upper) {  
    if (root == null) {  
        return true;  
    }  
    if (root.val <= lower || root.val >= upper) {  
        return false;  
    }  
    // 每次递归用当前节点的上下限进一步限制左右子树的上下限  
    // 左子树下限不能低于当前节点的上限，上限不能超过当前节点值  
    // 右子树下限不能低于当前节点值，上限不能超过当前节点的上限  
    return validBST(root.left, lower, root.val) && validBST(root.right, root.val, upper);  
}  
  
public boolean isValidBST(TreeNode root) {  
    return validBST(root, Long.MIN_VALUE, Long.MAX_VALUE);  
}
```
> 另一种思路是将二叉树按中序遍历结果展开为数组，判断数组是否是有序的  
# 530.二叉搜索树的最小绝对差
> 给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。
## 题解
> 二叉搜索树的中序遍历结果是有序的，因此先进行中序遍历，再依次计算相邻位置上元素之差，取最小即可  
```java
/**  
 * 中序遍历并保存结果  
 */  
public void middleTraversal(TreeNode node, List<Integer> list) {  
    if (node == null) {  
        return;  
    }  
    middleTraversal(node.left, list);  
    list.add(node.val);  
    middleTraversal(node.right, list);  
}  
  
public int getMinimumDifference(TreeNode root) {  
    List<Integer> list = new ArrayList<>();  
    middleTraversal(root, list);  
    int min = Integer.MAX_VALUE;  
    for (int i = 1; i < list.size(); i++) {  
        min = Integer.min(min, Math.abs(list.get(i) - list.get(i - 1)));  
    }  
    return min;  
}
```
# 501.二叉搜索树中的众数
> 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。  
> 左孩子结点小于等于根节点，右孩子结点大于等于根节点  
# 题解
> 中序遍历后得到有序的数组，相同数值排列在一起，可以用双指针法计算相同数值的个数;；   
> 也可以在遍历过程中比较前一个节点与当前节点值，动态统计相同值结点数并收集结果；  
```java
class Solution {  
  
    private TreeNode pre;  
    private List<Integer> result = new ArrayList<>();  
    private int maxCount;  
    private int count;  
  
    public void traversal(TreeNode node) {  
        if (node == null) {  
            return;  
        }  
  
        // 遍历左子树  
        traversal(node.left);  
  
        // 处理中节点  
        // 遍历的前一个节点为空（根节点），初始计数  
        if (pre == null) {  
            count = 1;  
        } else if (node.val != pre.val) {  
            // 当前节点值不等于前一个节点值，重置计数  
            count = 1;  
        } else {  
            // 当前节点值与遍历前一个节点值相等，计数更新  
            count++;  
        }  
        // 计数值处理  
        if (count == maxCount) {  
            // 达到当前最大计数，添加到结果集中  
            result.add(node.val);  
        } else if (count > maxCount) {  
            // 超过当前最大计数，清空结果集，更新结果集并更新最大计数  
            result.clear();  
            result.add(node.val);  
            maxCount = count;  
        }  
        // 中节点处理完，更新遍历前节点指针  
        pre = node;  
  
        // 遍历右子树  
        traversal(node.right);  
    }  
  
    public int[] findMode(TreeNode root) {  
        traversal(root);  
        int[] ret = new int[result.size()];  
        for (int i = 0; i < result.size(); i++) {  
            ret[i] = result.get(i);  
        }  
        return ret;  
    }  
}
```
# 235.二叉搜索树的最近公共祖先
> 类似于二叉树的最近公共祖先，但可以利用二叉搜索树的特性简化  
> 二叉搜索树中根节点值大于左子树、小于右子树  
> 如果目标节点在根节点左右两边，则根节点即是公共祖先  
> 如果目标节点分布在一侧的子树，则可以缩小区间直到将左右子树分布到两边子树中  
```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {  
    while (root != null) {  
        if (root.val > p.val && root.val > q.val) {  
            // 根节点值大于目标p、q节点值，p、q在左子树，缩小区间到左子树进一步筛查  
            root = root.left;  
        } else if (root.val < p.val && root.val < q.val) {  
            // 根节点值小于目标p、q节点值，p、q在右子树，缩小区间到右子树进一步筛查  
            root = root.right;  
        } else {  
            // 根节点值位于目标p、q节点值之间，则根节点即是公共祖先  
            return root;  
        }  
    }  
    return root;  
}
```
# 701.二叉搜索树中的插入操作
给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。    
> 目标值比中节点值小，则应该插入到左子树，递归直到合适空节点位置插入，回溯更新左孩子;  
> 目标值比中节点值大，则应该插入到右子树，递归直到合适空节点位置插入，回溯更新右孩子;  
```java
public TreeNode insertIntoBST(TreeNode root, int val) {  
    if (root == null) {  
        return new TreeNode(val);  
    }  
    if (root.val > val) {  
        // 值比根节点小，往左子树插入，左孩子指向插入后的左子树根节点  
        root.left = insertIntoBST(root.left, val);  
    } else if (root.val < val) {  
        // 值比根节点大，往右子树插入，右孩子指向插入后的右子树根节点  
        root.right = insertIntoBST(root.right, val);  
    }  
    return root;  
}
```
# 450.删除二叉搜索树中的节点
给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。
## 题解
> 删除一个节点时，如果其左子树为空，则直接返回右子树；  
> 删除一个节点时，如果其右子树为空，则直接返回左子树；
> 删除一个节点时，如果其左右子树均非空，则返回其右子树，但需要把其左子树挂到右子树的最左叶子节点上；  
```java
public TreeNode deleteNode(TreeNode root, int key) {  
    if (root == null) {  
        return null;  
    }  
    // 找到待删除节点  
    if (root.val == key) {  
        if (root.left == null) {  
            return root.right; // 待删除节点左子树为空，则直接返回其右子树  
        } else if (root.right == null) {  
            return root.left; // 待删除节点右子树为空，则直接返回其左子树  
        } else {  
            // 待删除节点左右子树均不为空，理论上是右子树上移，重新处理左子树  
            TreeNode tmpRoot = root.right;  
            while (tmpRoot.left != null) {  
                tmpRoot = tmpRoot.left;  
            }  
            // 待删除节点左子树需要挂载到待删除节点右子树的最左左叶子节点上  
            tmpRoot.left = root.left;  
            return root.right;  
        }  
    } else if (root.val > key) {  
        // 目标值小于根节点值，则在左子树中删除，并重新挂载左子树  
        root.left = deleteNode(root.left, key);  
    } else if (root.val < key) {  
        // 目标值大于根节点值，则在右子树中删除，并重新挂载右子树  
        root.right = deleteNode(root.right, key);  
    }  
    return root;  
}
```
# 669.修剪二叉搜索树
给你二叉搜索树的根节点 `root` ，同时给定最小边界`low` 和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。修剪树 **不应该** 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 **唯一的答案** 。  

所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。
```java
public TreeNode trimBST(TreeNode root, int low, int high) {  
    if (root == null) {  
        return null;  
    }  
    // 根节点值小于区间下限，则整棵左子树都不符，直接删掉  
    if (root.val < low) {  
        root.left = null;  
    }  
    // 根节点值大于区间上限，则整棵右子树都不符，直接删掉  
    if (root.val > high) {  
        root.right = null;  
    }  
    // 对左子树进行递归修剪  
    root.left = trimBST(root.left, low, high);  
    // 对右子树进行递归修剪  
    root.right = trimBST(root.right, low, high);  
    // 修剪完看下根节点情况，符合区间直接返回根节点  
    if (root.val >= low && root.val <= high) {  
        return root;  
    } else if (root.val < low) {  
        // 根节点值小于下限，则取右子树  
        return root.right;  
    } else if (root.val > high) {  
        // 根节点值大于上限，则取左子树  
        return root.left;  
    }  
    return null;  
}
```
# 108.将有序数组转换为二叉搜索树
给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。

**高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
## 题解
> 类似于二分查找的递归法  
```java
class Solution {  
  
    public TreeNode buildBST(int[] nums, int left, int right) {  
        if (left > right) {  
            return null;  
        }  
        int mid = left + (right - left) / 2;  
        // 选中间值作为根节点  
        TreeNode node = new TreeNode(nums[mid]);  
        // 从左区间构建左孩子  
        node.left = buildBST(nums, left, mid - 1);  
        // 从右区间构建右孩子  
        node.right = buildBST(nums, mid + 1, right);  
        return node;  
    }  
  
    public TreeNode sortedArrayToBST(int[] nums) {  
        return buildBST(nums, 0, nums.length - 1);  
    }  
}
```
