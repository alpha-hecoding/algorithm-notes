# 242.有效的字母异位词
> 判断两个字符串是否右相同的且数量相同的字符组成
> 采用hash表的思想，先对一个字符串按字符出现次数统计，与另一个字符串的字符出现次数比较
```java
public boolean isAnagram(String s, String t) {  
    int[] map = new int[26];  
    final char[] c1 = s.toCharArray();  
    // 对字符串中  
    for (char c : c1) {  
        map[c - 'a']++;  
    }  
    final char[] c2 = t.toCharArray();  
    for (char c : c2) {  
        map[c - 'a']--;  
    }  
    for (int i : map) {  
        if (i != 0) {  
            return false;  
        }  
    }  
    return true;  
}
```
# 349.两个数组的交集
> 用set去重并判断是否出现过
```java
public int[] intersection(int[] nums1, int[] nums2) {  
    Set<Integer> s1 = new LinkedHashSet<>();  
    for (int i : nums1) {  
        s1.add(i);  
    }  
    Set<Integer> result = new LinkedHashSet<>();  
    for (int i : nums2) {  
        if (s1.contains(i)) {  
            result.add(i);  
        }  
    }  
    int[] array = new int[result.size()];  
    int k = 0;  
    for (Integer i : result) {  
        array[k++] = i;  
    }  
    return array;  
}
```
# 202.快乐数
> 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。  
> 输入：19  
> 输出：true  
> 解释：  
> 1^2 + 9^2 = 82  
> 8^2 + 2^2 = 68  
> 6^2 + 8^2 = 100  
> 1^2 + 0^2 + 0^2 = 1  
- 拆出数值中的每一位整数  
- 求和之后的数用hash缓存起来，避免死循环  
```java
public boolean isHappy(int n) {  
    Set<Integer> records = new HashSet<>();  
    while (n != 1 && !records.contains(n)) {  
        // 记录出现过的数  
        records.add(n);  
        n = getSum(n);  
    }  
    return n == 1;  
}  
  
public int getSum(int n) {  
    int sum = 0;  
    while (n > 0) {  
        int m = n % 10; // 求余  
        sum += m * m;  
        n = n / 10; // 被10整除后的数  
    }  
    return sum;  
}
```
# 1.两数之和
> 用HasHMap存放已经遍历过的数
```java
public int[] twoSum(int[] nums, int target) {  
    Map<Integer, Integer> map = new HashMap<>(nums.length);  
    for (int i = 0; i < nums.length; i++) {  
        final Integer j = map.get(target - nums[i]);  
        if (j != null) {  
            return new int[] {j, i};  
        }  
        map.put(nums[i], i);  
    }  
    return new int[] {-1, -1};  
}
```
# 454.四数相加二
给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：

- `0 <= i, j, k, l < n`
- `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`
> 四个数组俩俩一组求和，缓存起来，然后类似两数之和求解
```java
public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {  
    int n = 0;  
    Map<Integer, Integer> map = new HashMap<>();  
    for (int i = 0; i < nums1.length; i++) {  
        for (int j = 0; j < nums2.length; j++) {  
            final int tmp = nums1[i] + nums2[j];  
            Integer count = map.get(tmp);  
            if (count == null) {  
                map.put(tmp, 1);  
            } else {  
                map.put(tmp, count + 1);  
            }  
        }  
    }  
    for (int i = 0; i < nums3.length; i++) {  
        for (int j = 0; j < nums4.length; j++) {  
            final int tmp = nums3[i] + nums4[j];  
            Integer count = map.get(0 - tmp);  
            if (count != null) {  
                n += count;  
            }  
        }  
    }  
    return n;  
}
```
# 383.赎金信
> 给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。  
> 类似于异构词，不同的是`magazine`中的字符可以超出`ransomNote`中的字符  
```java
public boolean canConstruct(String ransomNote, String magazine) {  
    final char[] chars = magazine.toCharArray();  
    int[] arr = new int[26];  
    for (char c : chars) {  
        arr[c - 'a']++;  
    }  
    for (char c : ransomNote.toCharArray()) {  
        arr[c - 'a']--;  
    }  
    for (int i : arr) {  
        if (i < 0) {  
            return false;  
        }  
    }  
    return true;  
}
```
# 15.三数之和
给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组.
> 双指针法。先排序，从左到右，先固定i，再找j、k，关键是对已处理过的数据去重
```java
public List<List<Integer>> threeSum(int[] nums) {  
    Arrays.sort(nums);  
    List<List<Integer>> ret = new ArrayList<>();  
    for (int i = 0; i < nums.length; i++) {  
        if (nums[i] > 0) {  
            return ret;  
        }  
        if (i > 0 && nums[i] == nums[i - 1]) {  
            continue; // 与前一位数值相同，上一轮循环已处理过，去重  
        }  
        int j = i + 1; // 左指针  
        int k = nums.length - 1; // 右指针  
        while (k > j) {  
            if (nums[i] + nums[j] + nums[k] > 0) {  
                k--; // 三数之和大于目标值，右指针左移  
            } else if (nums[i] + nums[j] + nums[k] < 0) {  
                j++; // 三数之和大于目标值，左指针右移  
            } else {  
                // 记录结果  
                ret.add(Arrays.asList(nums[i], nums[j], nums[k]));  
                j++; // 当前数值已使用，左指针右移  
                k--; // 当前数值已使用，右指针左移  
                // 移位后的左指针与前一位相同，则需要去重  
                while (k > j && nums[j] == nums[j - 1]) {  
                    j++;  
                }  
                // 移位后的右指针与后一位相同，则需要去重  
                while (k > j && nums[k] == nums[k + 1]) {  
                    k--;  
                }  
            }  
        }  
    }  
    return ret;  
}
```
# 18.四数之和
给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

**注意：**

答案中不可以包含重复的四元组。

示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]
> 类似三数之和，也是采用双指针的方法，固定i，依次遍历j，然后左右指针移动调整  
> 细节问题比较多，尤其注意提前结束循环时负数与负数相加会变成更小的负数  
```java
public List<List<Integer>> fourSum(int[] nums, int target) {  
    Arrays.sort(nums);  
    List<List<Integer>> ret = new ArrayList<>();  
    for (int i = 0; i < nums.length; i++) {  
        // 提前结束，注意负数与负数相加会更小，因此只有当起点大于0时累计和才会越来越大  
        if (nums[i] > target && nums[i] > 0) {  
            return ret;  
        }  
        // 对一个数去重  
        if (i > 0 && nums[i] == nums[i - 1]) {  
            continue;  
        }  
        for (int j = i + 1; j < nums.length; j++) {  
            final int tmp = nums[i] + nums[j];  
            if (tmp > target && tmp > 0) {  
                break; // 注意此处是break，不是直接return  
            }  
            // 与前一个j值相比较，相等的则已处理过，需要去重  
            if (j > i + 1 && nums[j] == nums[j - 1]) {  
                continue;  
            }  
            int l = j + 1; // 左指针  
            int r = nums.length - 1; // 右指针  
            while (r > l) {  
                if (tmp + nums[l] + nums[r] > target) {  
                    r--; // 四数之和大于目标值，右指针左移  
                } else if (tmp + nums[l] + nums[r] < target) {  
                    l++; // 四数之和小于目标值，左指针右移  
                } else {  
                    // 四数之和满足目标值，记录数据  
                    ret.add(Arrays.asList(nums[i], nums[j], nums[l], nums[r]));  
                    // 左右指针已使用，则需要移位  
                    l++;  
                    r--;  
                    while (r > l && nums[l] == nums[l - 1]) {  
                        l++;  
                    }  
                    while (r > l && nums[r] == nums[r + 1]) {  
                        r--;  
                    }  
                }  
            }  
        }  
    }  
    return ret;  
}
```