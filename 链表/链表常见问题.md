# 203.移除链表元素
> 移除链表中值符合给定值的结点
```java
public ListNode removeElements(ListNode head, int val) {  
    ListNode dummy = new ListNode(-1, head);  
    ListNode pre = dummy; // 前驱指针  
    ListNode curr = head; // 当前指针  
    while (curr != null) {  
        // 结点符合要求，待删除  
        if (curr.val == val) {  
            pre.next = curr.next;  
        } else {  
            pre = curr;  
        }  
        curr = curr.next;  
    }  
    return dummy.next;  
}
```
# 707.设计链表
> 链表增删改查
```java
class MyLinkedList {  
  
    class ListNode {  
        int val;  
        ListNode next;  
  
        public ListNode(int val) {  
            this.val = val;  
        }  
    }  
  
    int size; // 容量  
    ListNode head; // 虚拟头结点  
  
    public MyLinkedList() {  
        size = 0;  
        head = new ListNode(-1);  
    }  
  
    public int get(int index) {  
        if (index < 0 || index >= size) {  
            return -1;  
        }  
        // 从真实节点开始往下查找  
        ListNode curr = head.next;  
        for (int i = 0; i < index; i++) {  
            curr = curr.next;  
        }  
        return curr.val;  
    }  
  
    public void addAtHead(int val) {  
        ListNode node = new ListNode(val);  
        node.next = head.next;  
        head.next = node;  
        size++;  
    }  
  
    public void addAtTail(int val) {  
        ListNode p = head;  
        while (p.next != null) {  
            p = p.next;  
        }  
        p.next = new ListNode(val);  
        size++;  
    }  
  
    public void addAtIndex(int index, int val) {  
        if (index < 0 || index > size) {  
            return;  
        }  
        ListNode pre = head; // 前驱结点  
        for (int i = 0; i < index; i++) {  
            pre = pre.next;  
        }  
        // 插入  
        ListNode node = new ListNode(val);  
        node.next = pre.next;  
        pre.next = node;  
        size++;  
    }  
  
    public void deleteAtIndex(int index) {  
        if (index < 0 || index >= size) {  
            return;  
        }  
        if (size == 0) {  
            return;  
        }  
        ListNode pre = head; // 前驱结点  
        for (int i = 0; i < index; i++) {  
            pre = pre.next;  
        }  
        // 删除  
        pre.next = pre.next.next;  
        size--;  
    }  
}
```

# 206.反转链表
> 采用双指针法反转
```java
public ListNode reverseList(ListNode head) {  
    if (head == null || head.next == null) {  
        return head;  
    }  
    ListNode pre = head;  
    ListNode curr = pre.next;  
    pre.next = null; // 先将头结点的next置为null  
    while (curr != null) {  
        ListNode next = curr.next; // 先保存后继结点  
        curr.next = pre; /// 当前节点翻转，指向前驱结点  
        pre = curr; // 前驱结点后移  
        curr = next; // 当前节点后移  
    }  
    return pre;  
}
```
> 递归法反转
```java
  
public ListNode reverseList(ListNode head) {  
    if (head == null || head.next == null) {  
        return head;  
    }  
    ListNode last = reverseList(head.next); // 递归反转，返回该结点之后子链表反转后的头结点  
    head.next.next = head; // 该头结点的下个节点指向自己  
    head.next = null; // 自己的下个节点为空  
    return last;  
}
```
# 24.两两交换链表中的结点
> 两个结点一组交换位置
```java
public ListNode swapPairs(ListNode head) {  
    ListNode dummy = new ListNode(-1, head);  
    ListNode pre = dummy; // 0  
    ListNode curr = dummy.next; // 1  
    while (curr != null && curr.next != null) {  
        ListNode next = curr.next; // 2  
        ListNode nextnext = curr.next.next; // 3  
        curr.next.next = curr; // 2->1  
        curr.next = nextnext; // 1->3  
        pre.next = next; // 0->2  
        pre = curr; //  
        curr = nextnext;  
    }  
    return dummy.next;  
}
```
# 19.删除链表的倒数第N个结点
> 双指针的思路，快指针先移动N步，然后快慢指针一起移动，使慢指针到达倒数第N个结点的前一个结点
```java
public ListNode removeNthFromEnd(ListNode head, int n) {  
    if (head == null) {  
        return null;  
    }  
    ListNode dummy = new ListNode(-1, head);  
    ListNode fast = dummy.next;  
    // 快指针从头结点开始往后移动n次  
    for (int i = 0; i < n && fast != null; i++) {  
        fast = fast.next;  
    }  
    ListNode slow = dummy;  
    // 快指针移到尾结点点，则慢指针移到倒数第n+1个结点  
    while (fast != null) {  
        fast = fast.next;  
        slow = slow.next;  
    }  
    // 慢指针删除后继结点，指向其后继结点的后继结点  
    slow.next = slow.next.next;  
    return dummy.next;  
}
```
# 160.链表相交
> 俩链表有相同结点，从该结点开始，往后结点都相同。  
> 计算俩链表的长度差，从距离公共结点相同距离的位置开始，会在公共结点首次相遇。
- 第一趟，短链表会先走到终点，让指针指向长链表的头结点
- 第二趟，长链表的指针走到终点，短链表的指针指向长链表从`头结点`到`与公共结点到短链表头结点`相同距离的位置
- 第三趟，长链表指针指向短链表，与指向长链表的指针，终会在公共结点相遇
```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {  
    if (headA == null || headB == null) {  
        return null;  
    }  
    // 谁先走到尾结点，就从另一个链表的头结点开始走  
    ListNode pA = headA;  
    ListNode pB = headB;  
    while (pA != null && pB != null) {  
        if (pA == pB) {  
            return pA;  
        }  
        pA = pA.next;  
        pB = pB.next;  
    }  
    if (pA == null) {  
        pA = headB; // 链表A先到达终点，链表A短些  
    } else {  
        pB = headA; // 链表B先到达终点，链表B短些  
    }  
    // 长链表的指针到达终点，另一指针走了链表长度相差的步数  
    while (pA != null && pB != null) {  
        pA = pA.next;  
        pB = pB.next;  
    }  
    if (pA == null) {  
        pA = headB; // 链表A长些  
    } else {  
        pB = headA; // 链表B长些  
    }  
    // 俩指针在相距相交点相同距离的位置上  
    while (pA != null && pB != null) {  
        if (pA == pB) {  
            return pA;  
        }  
        pA = pA.next;  
        pB = pB.next;  
    }  
    return null;  
}
```
# 142.环形链表二
> 快慢双指针法，有环则快慢指针终会在环中相遇  
> 相遇时快指针比慢指针多走环的倍数  
> 相遇时快指针指向头部，他们会在环的入口处再次相遇  
```java
public ListNode detectCycle(ListNode head) {  
    // 判断是否有环  
    if (head == null || head.next == null) {  
        return null;  
    }  
    ListNode slow = head.next;  
    ListNode fast = head.next.next;  
    while (slow != fast) {  
        if (fast == null || fast.next == null) {  
            return null;  
        }  
        slow = slow.next;  
        fast = fast.next.next;  
    }  
    // 寻找环的入口  
    fast = head;  
    while (slow != fast) {  
        slow = slow.next;  
        fast = fast.next;  
    }  
    return fast;  
}
```
