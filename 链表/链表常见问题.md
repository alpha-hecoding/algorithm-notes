# 203.移除链表元素
> 移除链表中值符合给定值的结点
```java
public ListNode removeElements(ListNode head, int val) {  
    ListNode dummy = new ListNode(-1, head);  
    ListNode pre = dummy; // 前驱指针  
    ListNode curr = head; // 当前指针  
    while (curr != null) {  
        // 结点符合要求，待删除  
        if (curr.val == val) {  
            pre.next = curr.next;  
        } else {  
            pre = curr;  
        }  
        curr = curr.next;  
    }  
    return dummy.next;  
}
```
# 707.设计链表
> 链表增删改查
```java
class MyLinkedList {  
  
    class ListNode {  
        int val;  
        ListNode next;  
  
        public ListNode(int val) {  
            this.val = val;  
        }  
    }  
  
    int size; // 容量  
    ListNode head; // 虚拟头结点  
  
    public MyLinkedList() {  
        size = 0;  
        head = new ListNode(-1);  
    }  
  
    public int get(int index) {  
        if (index < 0 || index >= size) {  
            return -1;  
        }  
        // 从真实节点开始往下查找  
        ListNode curr = head.next;  
        for (int i = 0; i < index; i++) {  
            curr = curr.next;  
        }  
        return curr.val;  
    }  
  
    public void addAtHead(int val) {  
        ListNode node = new ListNode(val);  
        node.next = head.next;  
        head.next = node;  
        size++;  
    }  
  
    public void addAtTail(int val) {  
        ListNode p = head;  
        while (p.next != null) {  
            p = p.next;  
        }  
        p.next = new ListNode(val);  
        size++;  
    }  
  
    public void addAtIndex(int index, int val) {  
        if (index < 0 || index > size) {  
            return;  
        }  
        ListNode pre = head; // 前驱结点  
        for (int i = 0; i < index; i++) {  
            pre = pre.next;  
        }  
        // 插入  
        ListNode node = new ListNode(val);  
        node.next = pre.next;  
        pre.next = node;  
        size++;  
    }  
  
    public void deleteAtIndex(int index) {  
        if (index < 0 || index >= size) {  
            return;  
        }  
        if (size == 0) {  
            return;  
        }  
        ListNode pre = head; // 前驱结点  
        for (int i = 0; i < index; i++) {  
            pre = pre.next;  
        }  
        // 删除  
        pre.next = pre.next.next;  
        size--;  
    }  
}
```

# 206.反转链表
> 采用双指针法反转
```java
public ListNode reverseList(ListNode head) {  
    if (head == null || head.next == null) {  
        return head;  
    }  
    ListNode pre = head;  
    ListNode curr = pre.next;  
    pre.next = null; // 先将头结点的next置为null  
    while (curr != null) {  
        ListNode next = curr.next; // 先保存后继结点  
        curr.next = pre; /// 当前节点翻转，指向前驱结点  
        pre = curr; // 前驱结点后移  
        curr = next; // 当前节点后移  
    }  
    return pre;  
}
```
> 递归法反转
```java
  
public ListNode reverseList(ListNode head) {  
    if (head == null || head.next == null) {  
        return head;  
    }  
    ListNode last = reverseList(head.next); // 递归反转，返回该结点之后子链表反转后的头结点  
    head.next.next = head; // 该头结点的下个节点指向自己  
    head.next = null; // 自己的下个节点为空  
    return last;  
}
```