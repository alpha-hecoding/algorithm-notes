# 1.环形链表
> 判断一个链表是否有环  
> 采用快慢指针方式，快指针每次走两步，慢指针每次走一步，如果有环，则他们最终会相遇  
```java
public boolean hasCycle(ListNode head) {  
    if (head == null || head.next == null) {  
        return false;  
    }  
    // 慢指针先走一步
    ListNode slow = head.next;
    // 快指针先走两步  
    ListNode fast = head.next.next;  
    while (slow != fast) {  
	    // 快指针先到了尾结点，则无环
        if (fast == null || fast.next == null) {  
            return false;  
        }  
        // 慢指针走一步
        slow = slow.next;
        // 快指针走两步  
        fast = fast.next.next;  
    }  
    // 快慢指针相遇，则有环
    return true;  
}
```

# 2.找到环形链表环的起始结点
> 其实是解数学题  
> - 定义x为起点到环起点的长度，y为环起点到快慢指针第一次相遇的结点的长度，o为环的长度。二者初次相遇时快指针比慢指针多走完一个环的长度  
> - 慢指针走的长度: x+y=L  
> - 快指针走的长度: x+y+o=2L  
> - 因此可以得出o=L，即初次相遇时慢指针刚好走完一个环的长度，快指针刚好走完两个环的长度  
> - 因此慢指针再次到达环的起点需要走过的路径为(x+o)-L=x，等于链表起点位置到环入口的长度  
> - 因此初次相遇时让快指针再从链表起点与慢指针相同步伐走动，再次相遇点即为环入口位置  
```java
public ListNode detectCycle(ListNode head) {  
    // 判断是否有环  
    if (head == null || head.next == null) {  
        return null;  
    }  
    ListNode slow = head.next;  
    ListNode fast = head.next.next;  
    while (slow != fast) {  
        if (fast == null || fast.next == null) {  
            return null;  
        }  
        slow = slow.next;  
        fast = fast.next.next;  
    }  
    // 寻找环的入口  
    fast = head;  
    while (slow != fast) {  
        slow = slow.next;  
        fast = fast.next;  
    }  
    return fast;  
}
```
# 3.反转链表
## 3.1递归简介
> 在计算机科学中，递归是一种重要的算法设计技术，它允许函数或过程调用自身。根据调用位置的不同，递归可以分为头递归和尾递归。
> - 头递归（Head Recursion）：指的是在函数或过程调用自身之前，首先执行一些其他操作
> - 尾递归（Tail Recursion）：尾递归则相反，指的是在函数或过程调用自身之后，执行一些其他操作
> - 需要注意的是，头递归和尾递归是递归的两种不同形式，它们在代码实现上略有差异。在一些编程语言中，编译器或解释器可能会对尾递归进行优化，将其转换为循环结构，以提高代码效率递归实现比较简单。  
## 3.2递归法实现反转链表
> 很明显采用尾递归法  
> - 先反转头结点之后的子链表（递归）
> - 再将头结点置为其原后继结点的后继结点，并将头结点与其原后继结点断开，避免形成环
```java
public ListNode reverseList(ListNode head) {  
    if (head == null || head.next == null) {  
        return head;  
    }  
    // 反转头结点之后的子链表  
    // 1 -> (2 <- 3 <- 4 <- 5)  
    final ListNode last = reverseList(head.next);  
    // 头结点的后继结点的后继结点重新指向头结点  
    head.next.next = head;  
    // 头结点变成尾结点，没有后继结点  
    head.next = null;  
    return last;  
}
```
# 4.删除链表指定结点
> 给定链表某个节点的值，找到这个结点并删除
```java
public ListNode deleteNode(ListNode head, int val) {  
	// 虚拟头结点，避免头结点为空的情况
    ListNode dummy = new ListNode(-1, head);  
    ListNode p = dummy;  
    while (p != null && p.next != null) {  
        if (p.next.val == val) {  
	        // 删除，后继结点移到后继结点的后继结点
            p.next = p.next.next;  
        }  
        p = p.next;  
    }  
    return dummy.next;  
}
```
# 5.找到链表的中间位置
> 如果链表有偶数个结点，则返回中间靠前结点
```java
public ListNode findMiddleNode(ListNode head) {  
    if (head == null) {  
        return null;  
    }  
    if (head.next == null) {  
        return head;  
    }  
    // 1->2->3  
    // 用双指针找到链表的中点  
    ListNode fast = head.next.next;  
    ListNode slow = head.next;  
    while (fast != null && fast.next != null) {  
        fast = fast.next.next;  
        slow = slow.next;  
    }  
    if (fast == null) {  
        // 偶数个结点  
        return slow;  
    } else if (fast.next == null) {  
        // 奇数个结点  
        return slow;  
    }  
}
```