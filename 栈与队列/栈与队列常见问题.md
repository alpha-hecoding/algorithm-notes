# 232.用栈实现队列
> 用一个栈作为入队序列，另一个栈作为出队序列  
> 出队时先从出栈弹出，如果栈为空，则把入栈中元素全部取出压入出栈中  
```java
class MyQueue {  
  
    private Stack<Integer> in;  
    private Stack<Integer> out;  
  
    public MyQueue() {  
        this.in = new Stack<>();  
        this.out = new Stack<>();  
    }  
  
    public void push(int x) {  
        this.in.push(x);  
    }  
  
    public int pop() {  
        if (this.out.empty()) {  
            while (!this.in.empty()) {  
                this.out.push(this.in.pop());  
            }  
        }  
        return this.out.pop();  
    }  
  
    public int peek() {  
        if (this.out.empty()) {  
            while (!this.in.empty()) {  
                this.out.push(this.in.pop());  
            }  
        }  
        return this.out.peek();  
    }  
  
    public boolean empty() {  
        return this.out.empty() && this.in.empty();  
    }  
}
```
# 225.用队列模拟栈
> 用两个队列模拟栈的操作  
-  一个队列用来做数据队列，其出队顺序模拟为栈的出栈顺序
- 另一个队列用来做辅助队列，处理在插入时翻转操作
```java
class MyStack {  
  
    private Queue<Integer> in; // 保持和栈一样的出栈元素顺序  
    private Queue<Integer> help; // 辅助队列，只在入栈时有用，入栈完清空  
  
    public MyStack() {  
        this.in = new LinkedList<>();  
        this.help = new LinkedList<>();  
    }  
  
    public void push(int x) {  
        // 先插入到辅助队列  
        this.help.add(x);  
        // 数据队列元素出队，插入到辅助队列  
        while (!this.in.isEmpty()) {  
            this.help.add(this.in.poll());  
        }  
        // 翻转，辅助队列出队，插回到数据队列  
        while (!this.help.isEmpty()) {  
            this.in.add(this.help.poll());  
        }  
    }  
  
    public int pop() {  
        return this.in.poll();  
    }  
  
    public int top() {  
        return this.in.peek();  
    }  
  
    public boolean empty() {  
        return this.in.isEmpty();  
    }  
}
```
# 20.有效的括号
给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。  
有效字符串需满足：  
1. 左括号必须用相同类型的右括号闭合。  
2. 左括号必须以正确的顺序闭合。  
3. 每个右括号都有一个对应的相同类型的左括号。  
> 配对是由近到远，类似于后进先出，因此适合栈这种结构，采用栈来储存应该匹配的括号  
```java
public boolean isValid(String s) {  
    if (s.length() <= 1) {  
        return false;  
    }  
    final char[] chars = s.toCharArray();  
    Stack<Character> stack = new Stack<>();  
    for (char c : chars) {  
        // 左括号时对应的右括号入栈  
        // 右括号时比较栈顶元素是否与当前右括号一致  
        switch (c) {  
            case '(':  
                stack.push(')');  
                break;  
            case '[':  
                stack.push(']');  
                break;  
            case '{':  
                stack.push('}');  
                break;  
            case ')':  
                if (stack.isEmpty() || stack.peek() != ')') {  
                    return false;  
                }  
                stack.pop();  
                break;  
            case ']':  
                if (stack.isEmpty() || stack.peek() != ']') {  
                    return false;  
                }  
                stack.pop();  
                break;  
            case '}':  
                if (stack.isEmpty() || stack.peek() != '}') {  
                    return false;  
                }  
                stack.pop();  
                break;  
            default:  
                break;  
        }  
    }  
    // 全部出栈，则全部配对完  
    return stack.isEmpty();  
}
```
# 1047.删除字符中所有的相邻重复项
给出由小写字母组成的字符串 `S`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。
在 S 上反复执行重复项删除操作，直到无法继续删除。  
在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。  
**示例：**
**输入：**"abbaca"
**输出：**"ca"
**解释：**
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
> 要比较相邻，适合用栈这种数据结构来操作
```java
public String removeDuplicates(String s) {  
    final char[] chars = s.toCharArray();  
    Stack<Character> stack = new Stack<>();  
    for (char c : chars) {  
        // 遇到不相同字符串则入栈，相同字符串则出栈  
        if (stack.empty() || stack.peek() != c) {  
            stack.push(c);  
        } else {  
            stack.pop();  
        }  
    }  
    char[] ret = new char[stack.size()];  
    for (int i = ret.length - 1; i >= 0; i--) {  
        ret[i] = stack.pop();  
    }  
    return new String(ret);  
}
```
> 或者采用双指针法，遇到相等则回退
```java
public String removeDuplicates(String s) {  
    final char[] chars = s.toCharArray();  
    int i = 0; // 当前保留位置  
    int j = 1; // 当前探查位置  
    while (j < chars.length) {  
        // 回退到首位之前，意味着首字符也被消掉，则首位直接赋值  
        // 保留位置与探查位置字符不相等，则保留位置前移一位且更新，探查位置前移一位  
        if (i == -1 || chars[i] != chars[j]) {  
            chars[i + 1] = chars[j];  
            i++;  
            j++;  
        } else {  
            // 保留字符与探查字符相等，保留字符回退一位，探查字符前移一位  
            i--;  
            j++;  
        }  
    }  
    // 保留字符回退到首字符之前，则全部消除，返回空字符串  
    if (i == -1) {  
        return "";  
    }  
    // 返回区间[0,i]之间的字符组成的新字符串  
    char[] ret = new char[i + 1];  
    for (int k = 0; k < ret.length; k++) {  
        ret[k] = chars[k];  
    }  
    return new String(ret);  
}
```
# 150.逆波兰表达式求值
给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437) 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

**注意：**

- 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
- 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
- 两个整数之间的除法总是 **向零截断** 。
- 表达式中不含除零运算。
- 输入是一个根据逆波兰表示法表示的算术表达式。
- 答案及所有中间计算结果可以用 **32 位** 整数表示。

**示例 1：**

**输入：**tokens = ["2","1","+","3","*"]
**输出：**9
**解释：**该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

**示例 2：**

**输入：**tokens = ["4","13","5","/","+"]
**输出：**6
**解释：**该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
> 后缀表达式求值，使用栈来解决。
- 遇到操作数则压入栈
- 遇到操作符则出栈俩操作数，计算后再入栈
- 最后返回栈顶元素
```java
public int evalRPN(String[] tokens) {  
    Stack<Integer> stack = new Stack<>();  
    int i = -1;  
    int j = -1;  
    for (String token : tokens) {  
        switch (token) {  
            case "+":  
                i = stack.pop();  
                j = stack.pop();  
                stack.push(j + i);  
                break;  
            case "-":  
                i = stack.pop();  
                j = stack.pop();  
                stack.push(j - i);  
                break;  
            case "*":  
                i = stack.pop();  
                j = stack.pop();  
                stack.push(j * i);  
                break;  
            case "/":  
                i = stack.pop();  
                j = stack.pop();  
                stack.push(j / i);  
                break;  
            default:  
                stack.push(Integer.parseInt(token));  
                break;  
        }  
    }  
    return stack.pop();  
}
```