# 509.斐波那契数
**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1

给定 `n` ，请计算 `F(n)` 。
## 题解
> 递推公式已经由题目给出，直接计算即可
```java
class Solution {  
    public int fib(int n) {  
        if (n == 0) {  
            return 0;  
        } else if (n == 1) {  
            return 1;  
        }  
        int[] dp = new int[n + 1];  
        dp[1] = 1;  
        for (int i = 2; i <= n; i++) {  
            dp[i] = dp[i - 1] + dp[i - 2];  
        }  
        return dp[n];  
    }  
}
```
# 70.爬楼梯
假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？
**示例 1：**

**输入：** n = 2
**输出：** 2
**解释：** 有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
## 题解
- dp数组定义：dp[i]表示爬到第i+1个阶梯位置的方法
- 递推公式：dp[i] = dp[i-1] + dp[i-2]，即可由前两个位置一次爬两步阶梯，或由前一个位置爬一次阶梯到达
- 初始化：dp[0]=1，dp[1]=2
```java
class Solution {  
    public int climbStairs(int n) {  
        if (n == 1) {  
            return 1; // 爬一阶到达  
        } else if (n == 2) {  
            return 2; // 爬两次一阶，或爬一次两阶到达  
        }  
        // dp[i]表示爬到第i+1阶的方法，递推公式为dp[i]=dp[i-1]+dp[i-2];  
        int[] dp = new int[n];  
        dp[0] = 1;  
        dp[1] = 2;  
        for (int i = 2; i < n; i++) {  
            dp[i] = dp[i - 1] + dp[i - 2];  
        }  
        return dp[n - 1];  
    }  
}
```
# 746.使用最小花费爬楼梯
给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。
## 题解
- dp数组定义：dp[i]表示爬到下标为i的台阶的最小花费。那么到达楼顶的最小花费即为下标为cost.length的dp数组值
- 递推公式：dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])，即到达当前台阶的最下花费为前面两阶台阶任选一台阶出发，到达该台阶的最小花费与从该台阶触发跳出的费用，取两种路径花费的最小值
- 初始化：dp[0] = 0, dp[1] = 0
```java
class Solution {  
    public int minCostClimbingStairs(int[] cost) {  
        // dp[i]表示爬到下标为i的台阶的最小花费  
        int[] dp = new int[cost.length + 1];  
        dp[0] = 0;  
        dp[1] = 0;  
        for (int i = 2; i <= cost.length; i++) {  
            // 爬到当前台阶最小花费，为前两级台阶中(任选一阶已经产生的最小花费+从该台阶跳出的费用)的最小值  
            dp[i] = Integer.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);  
        }  
        return dp[cost.length];  
    }  
}
```
# 62.不同路径
一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？
## 题解
- dp数组：dp\[i]\[j]表示到达位置(i,j)时的路径
- 递推公式：dp\[i]\[j] = dp\[i-1]\[j] + dp\[i]\[j-1]，即从当前所在位置的前一行或前一列位置，能到达当前位置，路径为到达前俩位置的路径之和
- 初始化：dp\[0]\[0~n-1]=1,dp\[0~m-1][0]=1，即到达第一行的任一位置只有一条路径，到达第一列的任一位置也只有一条路径
```java
class Solution {  
    public int uniquePaths(int m, int n) {  
        // dp[i][j]表示到达(i,j)位置的路径  
        int[][] dp = new int[m][n];  
        // 初始化：到达第一行的任一位置只有一条路径，到达第一列的任一位置也只有一条路径  
        for (int j = 0; j < n; j++) {  
            dp[0][j] = 1;  
        }  
        for (int i = 0; i < m; i++) {  
            dp[i][0] = 1;  
        }  
        // 递推公式：dp[i][j] = dp[i-1][j] + dp[i][j-1]  
        for (int i = 1; i < m; i++) {  
            for (int j = 1; j < n; j++) {  
                // 从当前所在位置的前一行或前一列位置，能到达当前位置，路径为到达前俩位置的路径之和  
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];  
            }  
        }  
        return dp[m - 1][n - 1];  
    }  
}
```
# 63.不同路径二
一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。
## 题解
- dp数组：dp\[i]\[j]表示到达位置(i,j)时的路径
- 递推公式：dp\[i]\[j] = dp\[i-1]\[j] + dp\[i]\[j-1]，即从当前所在位置的前一行或前一列位置，能到达当前位置，路径为到达前俩位置的路径之和。需要注意，当前位置有障碍物时不可达，路径为0。
- 初始化：理论上dp\[0]\[0~n-1]=1,dp\[0~m-1][0]=1，即到达第一行的任一位置只有一条路径，到达第一列的任一位置也只有一条路径，但一旦遇到障碍物，则障碍物位置及其以后位置都不可达，需要初始为0.
```java
class Solution {  
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {  
        int m = obstacleGrid.length;  
        int n = obstacleGrid[0].length;  
        // dp[i][j]表示到达(i,j)位置的路径  
        int[][] dp = new int[m][n];  
        // 初始化  
        // 第一行，从起始位置到第一个障碍物位置路径上的位置，只有一条路径，其后走不通了，没有路径  
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) {  
            dp[0][j] = 1;  
        }  
        // 第一列，从起始位置到第一个障碍物位置路径上的位置，只有一条路径，其后走不通了，没有路径  
        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) {  
            dp[i][0] = 1;  
        }  
        for (int i = 1; i < m; i++) {  
            for (int j = 1; j < n; j++) {  
                // 该位置没有障碍物，可达  
                if (obstacleGrid[i][j] == 0) {  
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];  
                }  
            }  
        }  
        return dp[m - 1][n - 1];  
    }  
}
```