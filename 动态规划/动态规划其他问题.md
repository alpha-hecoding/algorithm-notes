# 198.打家劫舍
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。
## 题解
类似爬楼梯。从前两位的位置与当前位置之和、与前一位置两者的最大值，即可可偷窃到的最高金额。
- dp数组：`dp[i]` 表示数组前i个元素能够偷窃到的最高金额
- 递推公式：`dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])`
- 初始化：`dp[0] = nums[0], dp[1] = max(nums[0], nums[1])`
```java
class Solution {  
    public int rob(int[] nums) {  
        if (nums.length == 1) {  
            return nums[0];  
        }  
        // dp[i] 表示数组前i个元素能够偷窃到的最高金额  
        int[] dp = new int[nums.length];  
        // 初始化：0取第一个，1取前两个中的最大值  
        dp[0] = nums[0];  
        dp[1] = Integer.max(nums[0], nums[1]);  
        for (int i = 2; i < nums.length; i++) {  
            // 递推公式：前一个或前第二个与当前和的最大值  
            dp[i] = Integer.max(dp[i - 2] + nums[i], dp[i - 1]);  
        }  
        return dp[nums.length - 1];  
    }  
}
```
# 213.打家劫舍(二)
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。
## 题解
> 与198题相比，区别是房屋是形成了环，因此从两种方案里取最优：算头不算尾、算尾不算头
```java
class Solution {  
  
    /**  
     * 从数组里选取一段进行打家劫舍  
     */  
    public int robByRange(int[] nums, int start, int end) {  
        if (start == end) {  
            return nums[start];  
        }  
        // dp[i]表示从数组的第start个元素开始的前i个元素里能够偷窃到的最高金额  
        int[] dp = new int[end - start + 1];  
        dp[0] = nums[start];  
        dp[1] = Integer.max(nums[start], nums[start + 1]);  
        for (int i = 2; i <= end - start; i++) {  
            // 递推公式：前一个或前第二个与当前和的最大值  
            dp[i] = Integer.max(dp[i - 2] + nums[start + i], dp[i - 1]);  
        }  
        return dp[end - start];  
    }  
  
    public int rob(int[] nums) {  
        if (nums.length == 1) {  
            return nums[0];  
        }  
        // 算头不算尾，算尾不算头  
        return Integer.max(robByRange(nums, 0, nums.length - 2), robByRange(nums, 1, nums.length - 1));  
    }  
}
```
# 337.打家劫舍(三)
小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。

除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。

给定二叉树的 `root` 。返回 _**在不触动警报的情况下** ，小偷能够盗取的最高金额_ 。
## 题解
> 二叉树的递归问题。显然当前节点的最高金额，由左右子树最高金额与当前节点金额组合而成
- 包含任一左右子节点，则不能包含当前节点，取左右子节点各自的最大值之和
- 不包含左右任一子节点，则可以包含当前节点，取左右子节点不包含子节点的值与当前节点值之和
> 因此递归遍历子树时需要返回包含该节点与不包含该节点两种选择下的各自最高金额
```java
class Solution {  
  
    /**  
     * 打劫处理，返回结果为劲包含两个元素的数组ret，ret[0]表示不包含该节点的最高金额，ret[1]表示包含该节点的最高金额  
     */  
    public int[] doRob(TreeNode root) {  
        if (root == null) {  
            return new int[] {0, 0};  
        }  
        final int[] left = doRob(root.left);  
        final int[] right = doRob(root.right);  
        // 包含任一左右子节点，则不能包含当前节点，取左右子节点各自的最大值之和  
        // 不包含左右任一子节点，则可以包含当前节点，取左右子节点不包含子节点的值与当前节点值之和  
        return new int[] {Integer.max(left[0], left[1]) + Integer.max(right[0], right[1]),  
                left[0] + right[0] + root.val};  
    }  
  
    public int rob(TreeNode root) {  
        final int[] ret = doRob(root);  
        return Integer.max(ret[0], ret[1]);  
    }  
}
```
# 121.买卖股票的最佳时机
给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。
## 题解
> 只能买卖一次。
- 贪心思路：最低价时买入，最高价时卖出，找到这个区间即可
- 动归思路：找到每天持有与未持有时，与前一天的收益的递推关系
> 每天有买入和卖出以及不买不卖三种选择，归结下来是持有与未持有两种状态，因此递推包含两种状态的递推，用二维数组记录状态
- dp数组：`dp[i][0]`表示 第i天 持有股票 可得到的最大利润，`dp[i][1]`表示 第i天 没有股票 可得到的最大利润
- 递推公式：`dp[i][0] = max(dp[i - 1][0], -prices[i])`，表示**前一天已经持有，今天继续持有，收益不变**，或**前一天未持有，今天持有，即之前在观望，今天花钱买入，收益为负的买入价格**；`dp[i][1] = max(dp[i - 1][0] + prices[i], dp[i - 1][1])`，表示**前一天已经持有，今天卖出，收益增加**，或**前一天未持有，今天仍未持有，仍在观望，收益不变**
- 初始化：`dp[0][0] = -prices[0]; // 第一天持有，则买入，收益为负`，`dp[0][1] = 0; // 第一天不持有，则不买入，收益为0`
```java
class Solution {  
    public int maxProfit(int[] prices) {  
        // 每天有买入和卖出两种选择，用二维数组来记录  
        int[][] dp = new int[prices.length][2];  
        // dp[i][0]表示 第i天 持有股票 可得到的最大利润  
        // dp[i][1]表示 第i天 没有股票 可得到的最大利润  
        // 初始化  
        dp[0][0] = -prices[0]; // 持有，则买入，收益为负  
        dp[0][1] = 0; // 不持有，则不买人，收益为0  
        for (int i = 1; i < prices.length; i++) {  
            // 前一天已经持有，今天继续持有，没有花钱也没有收入，收益不变  
            // 前一天未持有，今天持有，即今天花钱买入，收益为负的买入价格  
            dp[i][0] = Integer.max(dp[i - 1][0], -prices[i]);  
            // 前一天已经持有，今天卖出，收益增加  
            // 前一天未持有，今天仍未持有，仍在观望，收益不变  
            dp[i][1] = Integer.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);  
        }  
        return Integer.max(dp[prices.length - 1][0], dp[prices.length - 1][1]);  
    }  
}
```
# 122.买卖股票的最佳时机(二)
给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 _你能获得的 **最大** 利润_ 。
## 题解
> 可以买卖多次，但手里最多只有一只股票。即买之前需要先卖出。
- 贪心思路：只要保证是挣钱的就行，累计的利润自然最大。一种方法是在开始挣钱时买入，开始亏钱的前一天卖出，自然在该阶段内挣得最多；另一种方法是分解到每天的利润里，即前一天买今天卖，只要取那些当天挣钱的天数，累加自然是最大利润。
- 动归思路：找到每天持有与未持有时，与前一天的收益的递推关系
> 每天有买入和卖出以及同时买入和卖出三种选择，归结下来是持有与未持有两种状态，因此递推包含两种状态的递推，用二维数组记录状态
- dp数组：`dp[i][0]`表示 第i天 持有股票 可得到的最大利润，`dp[i][1]`表示 第i天 没有股票 可得到的最大利润
- 递推公式：`dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])`，表示**前一天已经持有，今天继续持有，收益不变**，或**前一天未持有，今天持有，即今天花钱买入，收益减去买入价格**；`dp[i][1] = max(dp[i - 1][0] + prices[i], dp[i - 1][1])`，表示**前一天已经持有，今天卖出，收益增加**，或**前一天未持有，今天仍未持有，仍在观望，收益不变**
- 初始化：`dp[0][0] = -prices[0]; // 第一天持有，则买入，收益为负`，`dp[0][1] = 0; // 第一天不持有，则不买入，收益为0`
```java
class Solution {  
    public int maxProfit(int[] prices) {  
        // 每天有买入和卖出两种选择，用二维数组来记录  
        int[][] dp = new int[prices.length][2];  
        // dp[i][0]表示 第i天 持有股票 可得到的最大利润  
        // dp[i][1]表示 第i天 没有股票 可得到的最大利润  
        // 初始化  
        dp[0][0] = -prices[0];  
        dp[0][1] = 0;  
        for (int i = 1; i < prices.length; i++) {  
            // 前一天已经持有，今天继续持有，收益不变  
            // 前一天未持有，今天持有，收益减去今天的花销即买入的价格  
            dp[i][0] = Integer.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);  
            // 前一天已经持有，今天卖出，收益增加  
            // 前一天未持有，今天仍未持有，仍在观望，收益不变  
            dp[i][1] = Integer.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);  
        }  
        return Integer.max(dp[prices.length - 1][0], dp[prices.length - 1][1]);  
    }  
}
```
