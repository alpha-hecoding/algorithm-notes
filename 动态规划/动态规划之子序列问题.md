# 300.最长递增子序列
给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

**输入：** nums = `[10,9,2,5,3,7,101,18]`
**输出：** 4
**解释：** 最长递增子序列是 `[2,3,7,101]`，因此长度为 4 。
## 题解
- dp数组：`dp[i]`表示取数组前i+1个元素，即下标`[0 ~ i]`的子数组时，其中最长严格递增子序列的长度；
- 递推公式：`if(nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1),其中j = 0 ~ i-1`，表示当子数组长度增加时，当前最长严格递增子序列长度可能在前面各子数组的最长严格递增子序列长度上加1；
- 初始化：各位置均初始化为1；
```java
class Solution {  
    public int lengthOfLIS(int[] nums) {  
        // dp[i]表示数组下标范围[0,i]下最长严格递增子序列长度  
        int[] dp = new int[nums.length];  
        // 初始化为1，因为最小子序列长度为1  
        Arrays.setAll(dp, a -> 1);  
        int max = 1; // 所有最大子序列长度的最大值  
        for (int i = 1; i < nums.length; i++) {  
            // 递推公式：数组长度+1时，前面子数组每个位置的最大递增子序列都有可能也+1  
            for (int j = 0; j < i; j++) {  
                if (nums[i] > nums[j]) {  
                    dp[i] = Integer.max(dp[i], dp[j] + 1);  
                }  
            }  
            // 更新所有中的最大值  
            if (dp[i] > max) {  
                max = dp[i];  
            }  
        }  
        return max;  
    }  
}
```
# 674.最长连续递增序列
给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。

**连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。
**示例 1：**

**输入：** nums = `[1,3,5,4,7]`
**输出：** 3
**解释：** 最长连续递增序列是 `[1,3,5]`, 长度为3。
尽管 `[1,3,5,7]` 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。
## 题解
此题直接求解也比较简单，遇到非递增点时重新计算，遇到递增点更新最长递增长度
```java
class Solution {  
    public int findLengthOfLCIS(int[] nums) {  
        int max = 1;  
        int start = 0;  
        for (int i = 1; i < nums.length; i++) {  
            if (nums[i] > nums[i - 1]) {  
                max = Integer.max(max, i - start + 1);  
            } else {  
                start = i;  
            }  
        }  
        return max;  
    }  
}
```
动态规划思路解题
- dp数组：`dp[i]`表示取数组前i+1个元素，即下标`[0 ~ i]`的子数组时，其中最长连续递增子序列的长度；
- 递推公式：`if (nums[i] > nums[i - 1]) dp[i] = dp[i - 1] + 1`，表示遇到递增点时，最长连续递增长度也加1，否则就是初始长度；
- 初始化：各位置均初始化为1；
```java
class Solution {  
    public int findLengthOfLCIS(int[] nums) {  
        // dp[i]表示下标[0,i]的连续递增子序列长度  
        int[] dp = new int[nums.length];  
        Arrays.setAll(dp, a -> 1);  
        int max = 1;  
        for (int i = 1; i < nums.length; i++) {  
            if (nums[i] > nums[i - 1]) {  
                dp[i] = dp[i - 1] + 1;  
            }  
            if (dp[i] > max) {  
                max = dp[i];  
            }  
        }  
        return max;  
    }  
}
```
# 718.最长重复子数组
给两个整数数组 `nums1` 和 `nums2` ，返回 _两个数组中 **公共的** 、长度最长的子数组的长度_ 。

**示例 1：**

**输入：** nums1 = `[1,2,3,2,1]`, nums2 = `[3,2,1,4,7]`
**输出：** 3
**解释：** 长度最长的公共子数组是 `[3,2,1]` 。
## 题解
暴力方式：从一个数组的每个位置开始，到另一个数组找到相同的起点往后遍历；
动态规划思路：
- dp数组：`dp[i][j]`表示分别取num1的前i个元素的子数组、取num2的前j个元素的子数组，两子数组的最长公共子数组的长度；
- 递推公式：当i、j增加时，如果增加的元素相等，则公共子数组长度也增加，即`if (nums1[i] == nums2[j]) dp[i + 1][j + 1] = dp[i][j] + 1`;
- 初始化：因为dp下标后移了一位，初始化使用默认值0，无需初始化；
```java
class Solution {  
    public int findLength(int[] nums1, int[] nums2) {  
        int max = 0;  
        // dp[i][j]表示取数组num1的前i个数字、num2的前j个数字的两子数组的最长公共子数组长度  
        int dp[][] = new int[nums1.length + 1][nums2.length + 1];  
        for (int i = 0; i < nums1.length; i++) {  
            for (int j = 0; j < nums2.length; j++) {  
                if (nums1[i] == nums2[j]) {  
                    dp[i + 1][j + 1] = dp[i][j] + 1;  
                }  
                if (dp[i + 1][j + 1] > max) {  
                    max = dp[i + 1][j + 1];  
                }  
            }  
        }  
        return max;  
    }  
}
```
# 1143.最长公共子序列
给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。
## 题解
子序列不要求连续
- dp数组：`dp[i][j]`表示text1的前i个字符组成的子串、text2的前j个字符组成的子串，两子串的最长公共子序列长度；
- 递推公式：两字符相等，则最长长度递增；否则最长长度取两子串分别少一个的情况下最长长度(包含了两子串都少一个的情况)
```
if (ch1[i] == ch2[j]) {  
    dp[i + 1][j + 1] = dp[i][j] + 1;  
} else {  
    dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);  
}
```
- 初始化：往后递推(i,j=>i+1,j+1)，初始化(i=0以及j=0的即可)，注意到结果下标后移了一位，即`dp[1][1]`表示各取第一个字符的结果，`dp[0][j]`或`dp[i][0]`表示有一个子串不取字符，自然结果为0，因此无需初始化；
```java
class Solution {  
    public int longestCommonSubsequence(String text1, String text2) {  
        // dp[i][j]表示text1的前i个字符组成的子串、text2的前j个字符组成的子串，两子串的最长公共子序列长度  
        int[][] dp = new int[text1.length() + 1][text2.length() + 1];  
        final char[] ch1 = text1.toCharArray();  
        final char[] ch2 = text2.toCharArray();  
        for (int i = 0; i < ch1.length; i++) {  
            for (int j = 0; j < ch2.length; j++) {  
                // 地推公式：两字符相等，则最长长度递增；否则最长长度取两子串分别少一个的情况下最长长度(包含了两子串都少一个的情况)  
                if (ch1[i] == ch2[j]) {  
                    dp[i + 1][j + 1] = dp[i][j] + 1;  
                } else {  
                    dp[i + 1][j + 1] = Integer.max(dp[i][j + 1], dp[i + 1][j]);  
                }  
            }  
        }  
        return dp[text1.length()][text2.length()];  
    }  
}
```
