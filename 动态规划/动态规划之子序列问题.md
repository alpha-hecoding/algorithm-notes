# 300.最长递增子序列
给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

**输入：** nums = `[10,9,2,5,3,7,101,18]`
**输出：** 4
**解释：** 最长递增子序列是 `[2,3,7,101]`，因此长度为 4 。
## 题解
- dp数组：`dp[i]`表示取数组前i+1个元素，即下标`[0 ~ i]`的子数组时，其中最长严格递增子序列的长度；
- 递推公式：`if(nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1),其中j = 0 ~ i-1`，表示当子数组长度增加时，当前最长严格递增子序列长度可能在前面各子数组的最长严格递增子序列长度上加1；
- 初始化：各位置均初始化为1；
```java
class Solution {  
    public int lengthOfLIS(int[] nums) {  
        // dp[i]表示数组下标范围[0,i]下最长严格递增子序列长度  
        int[] dp = new int[nums.length];  
        // 初始化为1，因为最小子序列长度为1  
        Arrays.setAll(dp, a -> 1);  
        int max = 1; // 所有最大子序列长度的最大值  
        for (int i = 1; i < nums.length; i++) {  
            // 递推公式：数组长度+1时，前面子数组每个位置的最大递增子序列都有可能也+1  
            for (int j = 0; j < i; j++) {  
                if (nums[i] > nums[j]) {  
                    dp[i] = Integer.max(dp[i], dp[j] + 1);  
                }  
            }  
            // 更新所有中的最大值  
            if (dp[i] > max) {  
                max = dp[i];  
            }  
        }  
        return max;  
    }  
}
```
# 674.最长连续递增序列
给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。

**连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。
**示例 1：**

**输入：** nums = `[1,3,5,4,7]`
**输出：** 3
**解释：** 最长连续递增序列是 `[1,3,5]`, 长度为3。
尽管 `[1,3,5,7]` 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。
## 题解
此题直接求解也比较简单，遇到非递增点时重新计算，遇到递增点更新最长递增长度
```java
class Solution {  
    public int findLengthOfLCIS(int[] nums) {  
        int max = 1;  
        int start = 0;  
        for (int i = 1; i < nums.length; i++) {  
            if (nums[i] > nums[i - 1]) {  
                max = Integer.max(max, i - start + 1);  
            } else {  
                start = i;  
            }  
        }  
        return max;  
    }  
}
```
动态规划思路解题
- dp数组：`dp[i]`表示取数组前i+1个元素，即下标`[0 ~ i]`的子数组时，其中最长连续递增子序列的长度；
- 递推公式：`if (nums[i] > nums[i - 1]) dp[i] = dp[i - 1] + 1`，表示遇到递增点时，最长连续递增长度也加1，否则就是初始长度；
- 初始化：各位置均初始化为1；
```java
class Solution {  
    public int findLengthOfLCIS(int[] nums) {  
        // dp[i]表示下标[0,i]的连续递增子序列长度  
        int[] dp = new int[nums.length];  
        Arrays.setAll(dp, a -> 1);  
        int max = 1;  
        for (int i = 1; i < nums.length; i++) {  
            if (nums[i] > nums[i - 1]) {  
                dp[i] = dp[i - 1] + 1;  
            }  
            if (dp[i] > max) {  
                max = dp[i];  
            }  
        }  
        return max;  
    }  
}
```
# 718.最长重复子数组
给两个整数数组 `nums1` 和 `nums2` ，返回 _两个数组中 **公共的** 、长度最长的子数组的长度_ 。

**示例 1：**

**输入：** nums1 = `[1,2,3,2,1]`, nums2 = `[3,2,1,4,7]`
**输出：** 3
**解释：** 长度最长的公共子数组是 `[3,2,1]` 。
## 题解
暴力方式：从一个数组的每个位置开始，到另一个数组找到相同的起点往后遍历；
动态规划思路：
- dp数组：`dp[i][j]`表示分别取num1的前i个元素的子数组、取num2的前j个元素的子数组，两子数组的最长公共子数组的长度；
- 递推公式：当i、j增加时，如果增加的元素相等，则公共子数组长度也增加，即`if (nums1[i] == nums2[j]) dp[i + 1][j + 1] = dp[i][j] + 1`;
- 初始化：因为dp下标后移了一位，初始化使用默认值0，无需初始化；
```java
class Solution {  
    public int findLength(int[] nums1, int[] nums2) {  
        int max = 0;  
        // dp[i][j]表示取数组num1的前i个数字、num2的前j个数字的两子数组的最长公共子数组长度  
        int dp[][] = new int[nums1.length + 1][nums2.length + 1];  
        for (int i = 0; i < nums1.length; i++) {  
            for (int j = 0; j < nums2.length; j++) {  
                if (nums1[i] == nums2[j]) {  
                    dp[i + 1][j + 1] = dp[i][j] + 1;  
                }  
                if (dp[i + 1][j + 1] > max) {  
                    max = dp[i + 1][j + 1];  
                }  
            }  
        }  
        return max;  
    }  
}
```
# 1143.最长公共子序列
给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。
## 题解
子序列不要求连续
- dp数组：`dp[i][j]`表示text1的前i个字符组成的子串、text2的前j个字符组成的子串，两子串的最长公共子序列长度；
- 递推公式：两字符相等，则最长长度递增；否则最长长度取两子串分别少一个的情况下最长长度(包含了两子串都少一个的情况)
```
if (ch1[i] == ch2[j]) {  
    dp[i + 1][j + 1] = dp[i][j] + 1;  
} else {  
    dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);  
}
```
- 初始化：往后递推(i,j=>i+1,j+1)，初始化(i=0以及j=0的即可)，注意到结果下标后移了一位，即`dp[1][1]`表示各取第一个字符的结果，`dp[0][j]`或`dp[i][0]`表示有一个子串不取字符，自然结果为0，因此无需初始化；
```java
class Solution {  
    public int longestCommonSubsequence(String text1, String text2) {  
        // dp[i][j]表示text1的前i个字符组成的子串、text2的前j个字符组成的子串，两子串的最长公共子序列长度  
        int[][] dp = new int[text1.length() + 1][text2.length() + 1];  
        final char[] ch1 = text1.toCharArray();  
        final char[] ch2 = text2.toCharArray();  
        for (int i = 0; i < ch1.length; i++) {  
            for (int j = 0; j < ch2.length; j++) {  
                // 地推公式：两字符相等，则最长长度递增；否则最长长度取两子串分别少一个的情况下最长长度(包含了两子串都少一个的情况)  
                if (ch1[i] == ch2[j]) {  
                    dp[i + 1][j + 1] = dp[i][j] + 1;  
                } else {  
                    dp[i + 1][j + 1] = Integer.max(dp[i][j + 1], dp[i + 1][j]);  
                }  
            }  
        }  
        return dp[text1.length()][text2.length()];  
    }  
}
```
# 1035.不相交的线
在两条独立的水平线上按给定的顺序写下 `nums1` 和 `nums2` 中的整数。

现在，可以绘制一些连接两个数字 `nums1[i]` 和 `nums2[j]` 的直线，这些直线需要同时满足满足：

- `nums1[i] == nums2[j]`
- 且绘制的直线不与任何其他连线（非水平线）相交。

请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。

以这种方法绘制线条，并返回可以绘制的最大连线数。
## 题解
与1143-最长公共子序列类似
- dp数组：`dp[i][j]`表示取数组num1的前i个数字、num2的前j个数字的两子数组可绘制的最大连线数；
- 递推公式：两数字相同，则可以连线，最大连线数+1；否则最大连线数保持为前一位数组时的最大连线数；
```
if (nums1[i] == nums2[j]) {  
    dp[i + 1][j + 1] = dp[i][j] + 1;  
} else {  
    dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);  
}
```
- 初始化：往后递推(i,j=>i+1,j+1)，初始化(i=0以及j=0的即可)，注意到结果下标后移了一位，即`dp[1][1]`表示各取第一个元素的结果，`dp[0][j]`或`dp[i][0]`表示有一个数组不取元素，自然结果为0，因此无需初始化；
```java
class Solution {  
    public int maxUncrossedLines(int[] nums1, int[] nums2) {  
        // dp[i][j]表示取数组num1的前i个数字、num2的前j个数字的两子数组可绘制的最大连线数  
        int[][] dp = new int[nums1.length + 1][nums2.length + 1];  
        for (int i = 0; i < nums1.length; i++) {  
            for (int j = 0; j < nums2.length; j++) {  
                // 可以连线，则最大连线数+1；否则保持为前一位子数组的最大连线数  
                if (nums1[i] == nums2[j]) {  
                    dp[i + 1][j + 1] = dp[i][j] + 1;  
                } else {  
                    dp[i + 1][j + 1] = Integer.max(dp[i][j + 1], dp[i + 1][j]);  
                }  
            }  
        }  
        return dp[nums1.length][nums2.length];  
    }  
}
```
# 53.最大子数组和
给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。
## 题解
之前用贪心思路做过，现在用动态规划的思路来解
- dp数组：`dp[i]`表示取到第i个元素时的具有最大和的连续子数组的和；
- 地推公式：`dp[i + 1] = max(dp[i] + nums[i], nums[i])`，表示取到当前元素时最大和的连续子数组的和，要么累加上当前元素，要么只取当前元素；
- 初始化：往后递推，初始化i=0时即可，注意到结果下标后移了一位，即`dp[0]`表示不取任何元素的结果，无实际意义，初始为0；
```java
class Solution {  
    public int maxSubArray(int[] nums) {  
        // dp[i] 表示取前i个元素的子数组的具有最大和的连续子数组的和  
        int[] dp = new int[nums.length + 1];  
        int max = Integer.MIN_VALUE;  
        for (int i = 0; i < nums.length; i++) {  
            dp[i + 1] = Integer.max(dp[i] + nums[i], nums[i]);  
            // 记录遍历过程中的最大值  
            max = Integer.max(dp[i + 1], max);  
        }  
        return max;  
    }  
}
```
# 392.判断子序列
给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。
## 题解
双指针法简单明了，两指针分别指向两个字符串，移动两个指针比较字符是否相等，直至移到字符末尾。

若采用动态规划思路来解，关键是找到递推关系。
- dp数组：`dp[i][j]`表示s取前i个字符组成子串1、t取前j个字符组成子串2，子串1是否是子串2的子序列；
- 递推公式：
```
// 字符相同，看前一位是否也是子串；否则延续前一位的结果  
if (cs[i] == ct[j]) {  
    dp[i + 1][j + 1] = dp[i][j] && true;  
} else {  
    dp[i + 1][j + 1] = dp[i + 1][j];  
}
```
- 初始化：从前向后递推，需要初始化`dp[0]`，`dp[0]`表示第一个字符串不取任何元素，即空字符串，默认是第二个字符串的子串；
```java
class Solution {  
    public boolean isSubsequence(String s, String t) {  
        if (s.length() > t.length()) {  
            return false;  
        }  
        final char[] cs = s.toCharArray();  
        final char[] ct = t.toCharArray();  
        // dp[i][j]表示s取前i个字符组成子串1、t取前j个字符组成子串2，子串1是否是子串2的子序列  
        boolean[][] dp = new boolean[cs.length + 1][ct.length + 1];  
        for (int j = 0; j <= ct.length; j++) {  
            // 第一个字符串不取字符，则默认是第二个字符串的子串  
            dp[0][j] = true;  
        }  
        for (int i = 0; i < cs.length; i++) {  
            for (int j = 0; j < ct.length; j++) {  
                // 字符相同，看前一位是否也是子串；否则延续前一位的结果  
                if (cs[i] == ct[j]) {  
                    dp[i + 1][j + 1] = dp[i][j] && true;  
                } else {  
                    dp[i + 1][j + 1] = dp[i + 1][j];  
                }  
            }  
        }  
        return dp[cs.length][ct.length];  
    }  
}
```
# 115.不同的子序列
给你两个字符串 `s` 和 `t` ，统计并返回在 `s` 的 **子序列** 中 `t` 出现的个数，结果需要对 109 + 7 取模。

**示例 1：**

**输入：** s = "rabbbit", t = "rabbit" 
**输出** **：** `3`
**解释：**
如下所示, 有 3 种可以从 s 中得到 `"rabbit" 的方案`。
`**rabb**b**it**`
`**ra**b**bbit**`
`**rab**b**bit**`

**示例 2：**

**输入：** s = "babgbag", t = "bag"
**输出** **：**`5`
**解释：**
如下所示, 有 5 种可以从 s 中得到 `"bag" 的方案`。 
`**ba**b**g**bag`
`**ba**bgba**g**`
`**b**abgb**ag**`
`ba**b**gb**ag**`
`babg**bag**`
## 题解
- dp数组：`dp[i][j]`表示s取前i个字符组成子串1、t取前j个字符组成子串2，子串1的子序列中出现子串2的个数；
- 递推公式：
	+ 两子串字符相同：两子串各退一位以及第一个子串退一位的结果之和；
	+ 两子串字符不相同：延续第一个子串退一位的结果；
```
if (cs[i] == ct[j]) {  
    dp[i + 1][j + 1] = dp[i][j] + dp[i][j + 1];  
} else {  
    dp[i + 1][j + 1] = dp[i][j + 1];  
}
```
- 初始化：从前像后递推，需要初始化`dp[i][0]`，`dp[i][0]`表示第一个子串长度为i、第二个子串为空时第一个子串的子序列中出现第二个子串的个数，显然为1；
```java
class Solution {  
    public int numDistinct(String s, String t) {  
        if (s.length() < t.length()) {  
            return 0;  
        }  
        final char[] cs = s.toCharArray();  
        final char[] ct = t.toCharArray();  
        // dp[i][j]表示s取前i个字符组成子串1、t取前j个字符组成子串2，子串1的子序列中出现子串2的个数  
        int[][] dp = new int[cs.length + 1][ct.length + 1];  
        for (int i = 0; i <= cs.length; i++) {  
            dp[i][0] = 1; // 初始化：子串2不取任何字符，为空串，子串1的子序列为空串的个数为1  
        }  
        for (int i = 0; i < cs.length; i++) {  
            for (int j = 0; j < ct.length && j <= i; j++) {  
                // 字符相同，则取各退一位以及第一个子串退一位的结果之和；否则取第一个子串退退一位的结果  
                if (cs[i] == ct[j]) {  
                    dp[i + 1][j + 1] = dp[i][j] + dp[i][j + 1];  
                } else {  
                    dp[i + 1][j + 1] = dp[i][j + 1];  
                }  
            }  
        }  
        return dp[cs.length][ct.length];  
    }  
}
```
# 583.两个字符串的删除操作
给定两个单词 `word1` 和 `word2` ，返回使得 `word1` 和 `word2` **相同**所需的**最小步数**。

**每步** 可以删除任意一个字符串中的一个字符。

**示例 1：**

**输入:** word1 = "sea", word2 = "eat"
**输出:** 2
**解释:** 第一步将 "sea" 变为 "ea" ，第二步将 "eat "变为 "ea"
## 题解
类似两个字符串的子序列、重复子串等问题，用动态规划的思路来解。
- dp数组：`dp[i][j]`表示word1取前i个字符组成的子串、word2取前j个字符组成的子串，使得两子串相同所需的最小步数；
- 递推公式：考虑比较的两个位置的字符的相等与不相等的情况，相等时则延续前一位的结果；不相等则要在前一位的基础上再加一步删除操作；
```
if (c1[i] == c2[j]) {  
    // 字符相同，延续各退一步的操作步数  
    dp[i + 1][j + 1] = dp[i][j];  
} else {  
    // 字符不相同，取各自退一步的步数+1的最小值，表示其中一个退一步即为删除一个，步数需要增加  
    dp[i + 1][j + 1] = Integer.min(dp[i + 1][j] + 1, dp[i][j + 1] + 1);  
}
```
- 初始化：从前往后递推，需要考虑`dp[i][0]`、`dp[0][j]`即分别有一个子串为空串的情况，此种情况下步数为另一个子串的长度；
```java
class Solution {  
    public int minDistance(String word1, String word2) {  
        final char[] c1 = word1.toCharArray();  
        final char[] c2 = word2.toCharArray();  
        // dp[i][j]表示word1取前i个字符组成的子串、word2取前j个字符组成的子串，使得两子串相同所需的最小步数  
        int[][] dp = new int[c1.length + 1][c2.length + 1];  
        for (int i = 1; i <= c1.length; i++) {  
            dp[i][0] = i; // 第二个子串取空串，结果为第一个子串的长度  
        }  
        for (int j = 1; j <= c2.length; j++) {  
            dp[0][j] = j; // 第一个子串取空串，结果为第二个子串的长度  
        }  
        for (int i = 0; i < c1.length; i++) {  
            for (int j = 0; j < c2.length; j++) {  
                if (c1[i] == c2[j]) {  
                    // 字符相同，延续各退一步的操作步数  
                    dp[i + 1][j + 1] = dp[i][j];  
                } else {  
                    // 字符不相同，取各自退一步的步数+1的最小值，表示其中一个退一步即为删除一个，步数需要增加  
                    dp[i + 1][j + 1] = Integer.min(dp[i + 1][j] + 1, dp[i][j + 1] + 1);  
                }  
            }  
        }  
        return dp[c1.length][c2.length];  
    }  
}
```
# 72.编辑距离
给你两个单词 `word1` 和 `word2`， _请返回将 `word1` 转换成 `word2` 所使用的最少操作数_ 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

**示例 1：**

**输入：** word1 = "horse", word2 = "ros"
**输出：** 3
**解释：**
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
## 题解
与583-两个字符串的删除操作类似，用动态规划的思路来解。
- dp数组：`dp[i][j]`表示word1取前i个字符组成的子串、word2取前j个字符组成的子串，使得两子串相同所需的最小步数；
- 递推公式：考虑比较的两个位置的字符的相等与不相等的情况，相等时直接延续前一步的操作结果；不相等时考虑在前一步的基础上如何操作(插入、删除、替换)来实现相等；
```
if (c1[i] == c2[j]) {  
    // 两字符相同，无需操作，延续前一位步数  
    dp[i + 1][j + 1] = dp[i][j];  
} else {  
    // 两字符不相同  
    // 都退一步 =》 替换，即在上一步的基础上增加一步替换操作  
    // 其中一个退一步 =》 删除，即在上一步的基础上增加一步删除/插入操作  
    dp[i + 1][j + 1] = Integer.min(dp[i][j] + 1, Integer.min(dp[i][j + 1] + 1, dp[i + 1][j] + 1));  
}
```
- 初始化：从前往后递推，需要考虑`dp[i][0]`、`dp[0][j]`即分别有一个子串为空串的情况，此种情况下步数为另一个子串的长度；
```java
class Solution {  
    public int minDistance(String word1, String word2) {  
        final char[] c1 = word1.toCharArray();  
        final char[] c2 = word2.toCharArray();  
        int[][] dp = new int[c1.length + 1][c2.length + 1];  
        for (int i = 1; i <= c1.length; i++) {  
            dp[i][0] = i; // 第二个子串取空串，结果为第一个子串的长度  
        }  
        for (int j = 1; j <= c2.length; j++) {  
            dp[0][j] = j; // 第一个子串取空串，结果为第二个子串的长度  
        }  
        for (int i = 0; i < c1.length; i++) {  
            for (int j = 0; j < c2.length; j++) {  
                if (c1[i] == c2[j]) {  
                    // 两字符相同，无需操作，延续前一位步数  
                    dp[i + 1][j + 1] = dp[i][j];  
                } else {  
                    // 两字符不相同  
                    // 都退一步 =》 替换，即在上一步的基础上增加一步替换操作  
                    // 其中一个退一步 =》 删除，即在上一步的基础上增加一步删除操作  
                    dp[i + 1][j + 1] = Integer.min(dp[i][j] + 1, Integer.min(dp[i][j + 1] + 1, dp[i + 1][j] + 1));  
                }  
            }  
        }  
        return dp[c1.length][c2.length];  
    }  
}
```
# 647.回文子串
给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的数目。

**回文字符串** 是正着读和倒过来读一样的字符串。

**子字符串** 是字符串中的由连续字符组成的一个序列。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

**示例 2：**

**输入：** s = "aaa"
**输出：** 6
**解释：** 6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
## 题解
### 双指针法
回文串是具有中心点，从中心点向两边扩散呈对称结构。需要注意的是中心点可以是一个点，也可以是两个点，例如aba、abba。因此从字符串的每个位置出发，按照以其作为中心点以及与其后一个点作为中心点，查找回文串数量累计即可。
```java
class Solution {  
    public int countSubstrings(String s) {  
        final char[] cs = s.toCharArray();  
        int ret = 0; // 结果  
        int head = 0; // 回文串头指针  
        int tail = 0; // 回文串尾指针  
        for (int i = 0; i < cs.length; i++) {  
            // 以i为中心向两边扩散，判断是否是回文串  
            head = i;  
            tail = i;  
            while (head >= 0 && tail <= cs.length - 1 && cs[head--] == cs[tail++]) {  
                ret++;  
            }  
            // 以i、i+1为中心向两边扩散，判断是否是回文串  
            head = i;  
            tail = i + 1;  
            while (head >= 0 && tail <= cs.length - 1 && cs[head--] == cs[tail++]) {  
                ret++;  
            }  
        }  
        return ret;  
    }  
}
```
### 动态规划法
回文子串是判断字符串从某个位置到某个位置的子串是回文串，用dp数组来记录那些计算过的位置。
- dp数组：`dp[i][j]`表示下标`[i,j]`的子串是否是回文串，注意`j>=i`才有意义；
- 递推公式：`dp[i][j] = (dp[i+1][j-1] || j<=i+1) && cs[i]==cs[j]`，即两位置字符串相等，且向内收缩一位后仍是回文串；
- 初始化：`if(i==j) dp[i][j] = true`，即单个字符也是回文串；
- 遍历顺序：由`i+1`倒推`i`，由`j-1`递推`j`，且注意到`j>=i`，确定遍历顺序；
```java
class Solution {  
    public int countSubstrings(String s) {  
        final char[] cs = s.toCharArray();  
        int ret = 0; // 结果  
        // dp[i][j]表示下标[i,j]的子串是否是回文串  
        boolean[][] dp = new boolean[cs.length][cs.length];  
        // 递推公式：dp[i][j] = (dp[i+1][j-1] || j<=i+1) && cs[i]==cs[j]  
        // 由i+1倒推i，由j-1递推j，且注意到j>=i，确定遍历顺序  
        for (int i = cs.length - 1; i >= 0; i--) {  
            for (int j = i; j < cs.length; j++) {  
                if (i == j) {  
                    // 位置相同，单个字符，是回文串  
                    ret++;  
                    dp[i][j] = true;  
                } else if (cs[i] == cs[j] && (j == i + 1 || dp[i + 1][j - 1])) {  
                    // 位置不同，按递推关系推导出是回文串  
                    ret++;  
                    dp[i][j] = true;  
                }  
            }  
        }  
        return ret;  
    }  
}
```
# 516.最长回文子序列
给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

**示例 1：**

**输入：** s = "bbbab"
**输出：** 4
**解释：** 一个可能的最长回文子序列为 "bbbb" 。
## 题解
参照647-回文子串的动态规划解题思路。
- dp数组：`dp[i][j]`表示下标`[i,j]`的子串的最长的回文子序列长度；
- 递推公式：`cs[i]==cs[j]`时，`dp[i][j] = dp[i+1][j-1] + 2`，表示结果长度新增了两字符；`cs[i]!=cs[j]`时，`dp[i][j] = max(dp[i+1][j], dp[i][j-1])`，表示分别退一步的子串的最大回文子序列长度的最大值；
- 初始化：`if(i==j) dp[i][j] = 1`，即单个字符也是回文串，其最大子串长度为1；
- 遍历顺序：由`i+1`倒推`i`，由`j-1`递推`j`，且注意到`j>=i`，确定遍历顺序；
```java
class Solution {  
    public int longestPalindromeSubseq(String s) {  
        final char[] cs = s.toCharArray();  
        // dp[i][j]表示下标[i,j]的子串的最长的回文子序列长度  
        int[][] dp = new int[cs.length][cs.length];  
        // 初始化  
        for (int i = 0; i < cs.length; i++) {  
            dp[i][i] = 1; // 单个字符的长度为1  
        }  
        // 递推公式：  
        // cs[i]==cs[j]时，dp[i][j] = dp[i+1][j-1] + 2  
        // cs[i]!=cs[j]时，dp[i][j] = max(dp[i+1][j], dp[i][j-1])  
        // 由i+1倒推i，由j-1递推j，且注意到j>=i，确定遍历顺序  
        for (int i = cs.length - 1; i >= 0; i--) {  
            for (int j = i + 1; j < cs.length; j++) {  
                if (cs[i] == cs[j]) {  
                    dp[i][j] = dp[i + 1][j - 1] + 2;  
                } else {  
                    // 延续前一位的结果  
                    dp[i][j] = Integer.max(dp[i + 1][j], dp[i][j - 1]);  
                }  
            }  
        }  
        return dp[0][cs.length - 1];  
    }  
}
```
