# 416.分割等和子集
给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
## 题解
分割为两个元素和相等的子集，即存在子集和为所有元素和的一半。可抽象为**01背包问题**，所有元素和一半为背包大小，选取元素放到背包中，元素即物品，物品重量以及价值皆为元素值，最终求取的是否能将背包放满。套用01背包解题思路如下：
- dp数组：dp\[j]表示背包大小为j时放置物品最大价值，也即组成和小于等于j的所有子集的最大子集元素和；
- 递推公式：dp\[j] = max(dp\[j], dp\[j-nums\[i]] + nums\[i]).即拿取任一元素，与除去该元素后组成新的背包的最大价值之和，所有组合中和的最大值；
- 初始化：数组元素皆为正整数，因此dp数组初始化为0；
```java
class Solution {  
    public boolean canPartition(int[] nums) {  
        // 检查数组长度  
        if (nums.length <= 1) {  
            return false;  
        }  
        // 检查数组和  
        final int sum = Arrays.stream(nums).sum();  
        if ((sum & 0x1) == 1) {  
            return false;  
        }  
        final int target = sum / 2;  
        // dp数组，dp[j]表示组成和小于等于j的子集的最大和  
        int[] dp = new int[target + 1];  
        // 递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);  
        // 表示dp[j]为当前大小与去掉数组任一数值之后目标值与去掉值之和的最大值  
        for (int i = 0; i < nums.length; i++) {  
            for (int j = target; j >= nums[i]; j--) {  
	            // 因为每个物品都重新计算一次dp数组，dp数组后面的依赖前面，如果正序遍历，会导致该物品在计算中可能会被计算多次
                dp[j] = Integer.max(dp[j], dp[j - nums[i]] + nums[i]);  
            }  
        }  
        return dp[target] == target;  
    }  
}
```
# 1049.最后一块石头的重量(二)
有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。  

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。  
## 题解
按照题意，尽量重量相同的石头相撞，剩下的重量会尽量小。可抽象为将石头划分分重量最接近的两堆，相撞后剩下的重量最小。即可抽象为01背包问题：从一堆石头中选取石头，重量小于等于所有石头重量一半的最大重量。即为其中一堆石头的重量，与另一堆石头重量之差即为结果。
- dp数组：dp\[j]表示背包大小为j时放置物品最大价值，也即组成重量小于等于j的所有石头组合的最大石头重量和；
- 递推公式：dp\[j] = max(dp\[j], dp\[j-nums\[i]] + nums\[i]).即拿取任一石头，与除去该石头后组成新的背包的最大价值之和，所有组合中重量和的最大值；
- 初始化：石头重量皆为正整数，因此dp数组初始化为0；
```java
class Solution {  
    public int lastStoneWeightII(int[] stones) {  
        if (stones.length == 1) {  
            return stones[0];  
        }  
        final int sum = Arrays.stream(stones).sum();  
        int target = sum / 2;  
        // dp数组：dp[j]表示组成和小于等于j的石头的最大重量和  
        int[] dp = new int[target + 1];  
        // 递推公式：dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);  
        // 表示dp[j]为当前大小与去掉石堆任一石头之后目标重量与去掉石头重量之和的最大值  
        for (int i = 0; i < stones.length; i++) {  
            for (int j = target; j >= stones[i]; j--) {  
                dp[j] = Integer.max(dp[j], dp[j - stones[i]] + stones[i]);  
            }  
        }  
        return (sum - dp[target]) - dp[target];  
    }  
}
```
