# 416.分割等和子集
给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
## 题解
分割为两个元素和相等的子集，即存在子集和为所有元素和的一半。可抽象为**01背包问题**，所有元素和一半为背包大小，选取元素放到背包中，元素即物品，物品重量以及价值皆为元素值，最终求取的是否能将背包放满。套用01背包解题思路如下：
- dp数组：`dp[j]`表示背包大小为j时放置物品最大价值，也即组成和小于等于j的所有子集的最大子集元素和；
- 递推公式：`dp[j] = max(dp[j], dp[j-nums[i]] + nums[i])`.即拿取任一元素，与除去该元素后组成新的背包的最大价值之和，所有组合中和的最大值；
- 初始化：数组元素皆为正整数，因此dp数组初始化为0；
```java
class Solution {  
    public boolean canPartition(int[] nums) {  
        // 检查数组长度  
        if (nums.length <= 1) {  
            return false;  
        }  
        // 检查数组和  
        final int sum = Arrays.stream(nums).sum();  
        if ((sum & 0x1) == 1) {  
            return false;  
        }  
        final int target = sum / 2;  
        // dp数组，dp[j]表示组成和小于等于j的子集的最大和  
        int[] dp = new int[target + 1];  
        // 递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);  
        // 表示dp[j]为当前大小与去掉数组任一数值之后目标值与去掉值之和的最大值  
        for (int i = 0; i < nums.length; i++) {  
            for (int j = target; j >= nums[i]; j--) {  
	            // 因为每个物品都重新计算一次dp数组，dp数组后面的依赖前面，如果正序遍历，会导致该物品在计算中可能会被计算多次
                dp[j] = Integer.max(dp[j], dp[j - nums[i]] + nums[i]);  
            }  
        }  
        return dp[target] == target;  
    }  
}
```
# 1049.最后一块石头的重量(二)
有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。  

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。  
## 题解
按照题意，尽量重量相同的石头相撞，剩下的重量会尽量小。可抽象为将石头划分分重量最接近的两堆，相撞后剩下的重量最小。即可抽象为01背包问题：从一堆石头中选取石头，重量小于等于所有石头重量一半的最大重量。即为其中一堆石头的重量，与另一堆石头重量之差即为结果。
- dp数组：`dp[j]`表示背包大小为j时放置物品最大价值，也即组成重量小于等于j的所有石头组合的最大石头重量和；
- 递推公式：`dp[j] = max(dp[j], dp[j-nums[i]] + nums[i])`.即拿取任一石头，与除去该石头后组成新的背包的最大价值之和，所有组合中重量和的最大值；
- 初始化：石头重量皆为正整数，因此dp数组初始化为0；
```java
class Solution {  
    public int lastStoneWeightII(int[] stones) {  
        if (stones.length == 1) {  
            return stones[0];  
        }  
        final int sum = Arrays.stream(stones).sum();  
        int target = sum / 2;  
        // dp数组：dp[j]表示组成和小于等于j的石头的最大重量和  
        int[] dp = new int[target + 1];  
        // 递推公式：dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);  
        // 表示dp[j]为当前大小与去掉石堆任一石头之后目标重量与去掉石头重量之和的最大值  
        for (int i = 0; i < stones.length; i++) {  
            for (int j = target; j >= stones[i]; j--) {  
                dp[j] = Integer.max(dp[j], dp[j - stones[i]] + stones[i]);  
            }  
        }  
        return (sum - dp[target]) - dp[target];  
    }  
}
```
# 494.目标和
给你一个非负整数数组 `nums` 和一个整数 `target` 。  

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：  

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。  
## 题解
### 回溯法
> 很容易想到回溯法，每个数字前有一个符号，符号可选`+`或`-`，实际求得这些符号满足预期结果的组合数量
```java
class Solution {  
  
    private int count = 0;  
    private LinkedList<Character> paths = new LinkedList<>();  
  
    private void backtracing(int[] nums, int target, int startIndex) {  
        if (startIndex == nums.length) {  
            if (target == 0 && paths.size()==nums.length) {  
                count++; // 符合条件，收割结果  
            }  
            return;  
        }  
        for (int i = startIndex; i < nums.length; i++) {  
            // 当前位置 取+号  
            paths.add('+');  
            backtracing(nums, target - nums[i], i + 1);  
            paths.removeLast();  
            // 当前位置 取-号  
            paths.add('-');  
            backtracing(nums, target + nums[i], i + 1);  
            paths.removeLast();  
        }  
    }  
  
    public int findTargetSumWays(int[] nums, int target) {  
        backtracing(nums, target, 0);  
        return count;  
    }  
}
```
### 动态规划法
将数组划分为两个部分，其一中都取`+`号，其二中都取`-`号，两部分之后为target，所有之后为sum，则取`+`号部分之后为`(sum+target)/2`，取`-`号部分之和为`(sum-target)/2`，因此可以转化为在数组中取子集，子集和为`(sum+target)/2`或`(sum-target)/2`的取法。即转换为01背包问题。
- dp数组：dp\[j]表示数组中取子集和为j的取法
- 递推公式：`dp[j] = sum(dp[j-nums[i]])`，即累加上取`num[i]`时，组成和为`j-nums[i]`的子集数量
- 初始化：`dp[0]=1`，地推公式要求初始化dp\[0]，考虑初始化操作，不取任一元素，和为0，取法只有一种，其它取法会在后续计算中补充
```java
class Solution {  
  
    public int findTargetSumWays(int[] nums, int target) {  
        // 数组总和为sum，目标为target，则有: left + right = sum; left - right = target; left = (sum + target) / 2  
        // 即转化为在数组中查找和为`(sum + target) / 2`的子集  
        final int sum = Arrays.stream(nums).sum();  
        if (target > sum || target < -sum || ((sum + target) & 0x1) == 1) {  
            // 目标值超出最大最小范围，无法满足  
            // 和与目标值为奇数，因left肯定是整数，则也无法满足  
            return 0;  
        }  
        final int left = (sum + target) / 2;  
        // dp数组：dp[j]表示组成和等于j的子集个数  
        int[] dp = new int[left + 1];  
        // dp数组初始值为0，但dp[0]初始为1  
        dp[0] = 1; // 这里不好理解，需要考虑这里是初始化操作，啥元素都不取，和为0，取法只有一种  
        for (int i = 0; i < nums.length; i++) {  
            for (int j = left; j >= nums[i]; j--) {  
                // 累加取num[i]时，组成和为j的子集数量  
                dp[j] += dp[j - nums[i]];  
            }  
        }  
        return dp[left];  
    }  
  
}
```
# 474.一和零
给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

**示例 1：**

**输入：** strs = `["10", "0001", "111001", "1", "0"]`, m = 5, n = 3
**输出：** 4
**解释：** 最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
## 题解
看起来和背包问题联系不大，按照常规动态规划思路解题
- dp数组：`dp[i][j]`表示最多有i个0和j个1的最大子集长度
- 递推公式：`dp[i][j] = max(dp[i][j], dp[i-zeroNums][j-oneNums] + 1)`，即按照字符串集合遍历时，按照当前字符串中字符0和1的数量找到前一状态，在前一状态的基础上`+`1即可
- 初始化：初始化为0
- 遍历顺序：状态是动态更新的，更新时需要倒序更新，避免重复计算。因为每轮计算用到上一轮计算的值，如果正序，则本轮计算会用到本轮计算的值，导致下一轮计算重复累计了
```java
class Solution {  
    public int findMaxForm(String[] strs, int m, int n) {  
        // dp数组：dp[i][j]表示最多有i个0和j个1的最大子集长度  
        int[][] dp = new int[m + 1][n + 1];  
        for (String str : strs) {  
            int zeroNums = 0;  
            int oneNums = 0;  
            for (char c : str.toCharArray()) {  
                if (c == '0') {  
                    zeroNums++;  
                } else if (c == '1') {  
                    oneNums++;  
                }  
            }  
            // 倒序计算，避免计算多次，每次计算用到上一次计算的值，如果正序，则本次计算会用到本次计算的值导致重复累计  
            for (int i = m; i >= zeroNums; i--) {  
                for (int j = n; j >= oneNums; j--) {  
                    // 前一状态+1  
                    dp[i][j] = Integer.max(dp[i][j], dp[i - zeroNums][j - oneNums] + 1);  
                }  
            }  
        }  
        return dp[m][n];  
    }  
}
```
# 518.零钱兑换
给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。  

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。  

假设每一种面额的硬币有无限个。  

题目数据保证结果符合 32 位带符号整数。  
## 题解
> 完全背包问题
- dp数组：`dp[j]`表示凑成总金额为j的硬币组合数；
- 递推公式：`dp[j] = sum(dp[j - coins[i]])`，即遍历硬币，排除该硬币的所有取法之和，前提是`coins` 中的所有值 **互不相同**；
- 初始化：组合问题，一般初始化`dp[0]=1`，表示凑成金额为0，则不取任一硬币，只有一种取法；
```java
class Solution {  
    public int change(int amount, int[] coins) {  
        // dp数组：dp[j]表示凑成总金额为j的硬币组合数  
        int[] dp = new int[amount + 1];  
        // 初始化：dp[0]=1,其它为0  
        dp[0] = 1; // 这里在初始化操作，凑成金额为0，则不取任一硬币，只有一种取法  
        for (int i = 0; i < coins.length; i++) {  
            for (int j = coins[i]; j <= amount; j++) {  
                // 递推公式: 排除该硬币的所有取法之和  
                dp[j] += dp[j - coins[i]];  
            }  
        }  
        return dp[amount];  
    }  
}
```
# 377.组合总和(四)
给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。  
请注意，顺序不同的序列被视作不同的组合。  
**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 1000`
- `nums` 中的所有元素 **互不相同**
- `1 <= target <= 1000`
## 题解
> 完全背包的排列问题
- dp数组：`dp[j]`表示组成和为j的元素组合个数；
- 递推公式：`dp[j] = sum(dp[j - nums[i]])`，遍历每个物品时，除去该物品数值后的子集和的组合数量累计；
- 初始化：组合问题，一般初始化`dp[0]=1`，题目限制了都为正整数，表示组成和为0的取法就是全都不取，只有一种取法；
- 遍历顺序：排列问题，顺序不同是不同的组合，先遍历背包，再遍历物品，保证随着背包容量增长所有物品再次遍历时是不同的顺序会累计到最终结果里；
```java
class Solution {  
    public int combinationSum4(int[] nums, int target) {  
        // 完全背包排列问题，先遍历背包，再遍历物品  
        // dp数组：dp[j]表示组成和为j的元素组合个数  
        int[] dp = new int[target + 1];  
        // 初始化：题目限制都为正整数，则组成和为0的只有一种取法，故初始化为1  
        dp[0] = 1;  
        // 递推公式：dp[j] = sum(dp[j - nums[i]]);  
        // 排列问题，位置不同是不同组合，先遍历背包，再遍历物品  
        for (int j = 0; j <= target; j++) {  
            for (int i = 0; i < nums.length; i++) {  
                if (j >= nums[i]) {  
                    dp[j] += dp[j - nums[i]];  
                }  
            }  
        }  
        return dp[target];  
    }  
}
```
# 322.零钱兑换
给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。  
**提示：**

- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 231 - 1`
- `0 <= amount <= 104`
## 题解
> 完全背包组合问题，需要注意求的是最小硬币数，更新dp数组时是按照最小值更新。还需要注意如果前一个状态未知，则当前状态也无法更新
- dp数组：`dp[j]`表示凑成总金额j所需的最少的硬币个数；
- 递推公式：`dp[j] = min(dp[j], dp[j-coins[i]] + 1)`；表示拿当前硬币刚好可以凑齐时硬币数+1，所有凑法的最小值；
- 初始化：`dp[j]=Integer.MAX_VALUE`，因为需要取最小值，故初始化为最大值。`dp[0]=0`，递推中会用到`dp[0]`，凑到金额为0的最少硬币数为0；
- 遍历顺序：完全背包的组合问题，先遍历物品，再遍历背包；
```java
class Solution {  
    public int coinChange(int[] coins, int amount) {  
        // dp数组：dp[j]表示凑成总金额j所需的最少的硬币个数  
        int[] dp = new int[amount + 1];  
        Arrays.fill(dp, Integer.MAX_VALUE); // 所有初始化为最大整数，因为要取最小值  
        dp[0] = 0; // dp[0]初始化为0，递推时用到  
        for (int i = 0; i < coins.length; i++) {  
            for (int j = coins[i]; j <= amount; j++) {  
                // dp[j - coins[i]]未初始化时表示凑不出j - coins[i]，也凑不出j  
                if (dp[j - coins[i]] != Integer.MAX_VALUE) {  
                    dp[j] = Integer.min(dp[j], dp[j - coins[i]] + 1);  
                }  
            }  
        }  
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];  
    }  
}
```
# 279.完全平方数
给你一个整数 `n` ，返回 _和为 `n` 的完全平方数的最少数量_ 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

## 题解
> 完全背包的组合问题
- dp数组：`dp[j]`表示和为j的完全平方数的最少数量；
- 递推公式：`dp[j] = min(dp[j], dp[j - i*i] + 1)`；
- 初始化：i由i个1组成，因此初始化为数组下标；
- 遍历顺序：完全背包的组合问题，先遍历物品，再遍历背包；
```java
class Solution {  
    public int numSquares(int n) {  
        // 完全背包组合问题  
        // dp数组：dp[j]表示和为j的完全平方数的最少数量  
        int[] dp = new int[n + 1];  
        // 初始化：i由i个1组成，因此初始化为数组下标  
        for (int i = 0; i < dp.length; i++) {  
            dp[i] = i; // i由i个1组成  
        }  
        // 物品循环上界为目标开方值，超过开方值的不用考虑  
        for (int i = 1; i <= (int) Math.sqrt(n); i++) {  
            for (int j = i * i; j <= n; j++) {  
                dp[j] = Integer.min(dp[j], dp[j - i * i] + 1);  
            }  
        }  
        return dp[n];  
    }  
}
```
# 139.单词拆分
给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。

**注意：** 不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例 2：**

**输入:** s = "applepenapple", wordDict = `["apple", "pen"]`
**输出:** true
**解释:** 返回 true 因为 `"`applepenapple`"` 可以由 `"`apple" "pen" "apple`" 拼接成`。
     注意，你可以重复使用字典中的单词。

## 题解
完全背包排列问题变通。取任意数量任意单词，有一种排列顺序排列后能组成目标字符串。
- dp数组：`dp[j]`表示`[0,j)`位置的子串是否能由字典组成；
- 递推公式：`dp[j] = dp[j] || (dp[j - word.length()] && word.equals(s.substring(j - word.length(), j)))`，切除尾部单词后剩下的也能由字典组成；
- 初始化：`dp[0]=true`，无实际含义，递推公式要用到，切除尾部单词后子串为空，结果应该为真
- 遍历顺序：考虑不同排列方式组成结果不同，按照完全背包排列问题来遍历，先遍历背包，再遍历物品
```java
class Solution {  
    public boolean wordBreak(String s, List<String> wordDict) {  
        // 完全背包排列问题变种  
        // dp数组：dp[j]表示下标从[0~j)的子串是否可以由字典单词组成  
        boolean[] dp = new boolean[s.length() + 1];  
        dp[0] = true; // 递推用到  
        // 不包含，因此从1开始  
        for (int j = 1; j <= s.length(); j++) {  
            for (int i = 0; i < wordDict.size(); i++) {  
                // 检测是否可以拼上当前单词  
                final String word = wordDict.get(i);  
                if (j >= word.length()) {  
                    dp[j] = dp[j] || (dp[j - word.length()] && word.equals(s.substring(j - word.length(), j)));  
                }  
            }  
        }  
        return dp[s.length()];  
    }  
}
```
