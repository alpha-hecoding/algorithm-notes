# 7.整数反转
给你一个 32 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 `[−231, 231 − 1]` ，就返回 0。

**假设环境不允许存储 64 位整数（有符号或无符号）。**
## 题解
- 将整数转成字符数组，利用双指针翻转
- 翻转后字符数组转换成整数，需要处理越界问题
```java
public int reverse(int x) {  
    String str = String.valueOf(x);  
    final char[] chars = str.toCharArray();  
    int i = x < 0 ? 1 : 0;  
    int j = chars.length - 1;  
    while (i < j) {  
        char t = chars[i];  
        chars[i] = chars[j];  
        chars[j] = t;  
        i++;  
        j--;  
    }  
    // 字符数组转整数，边界处理  
    int target = 0;  
    int multiple = 1;  
    for (int k = chars.length - 1; k >= (x < 0 ? 1 : 0); k--) {  
        int c = chars[k] - '0';  
        // 当前数值与最大数值差值小于位数*倍数，则会溢出，直接结束  
        if ((Integer.MAX_VALUE - target) / multiple < c) {  
            target = 0;  
            break;  
        }  
        target += multiple * c;  
        multiple *= 10;  
    }  
    return target == 0 ? 0 : (x > 0 ? target : -target);  
}
```
# 8.字符串转整数
请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 `atoi` 函数）。

函数 `myAtoi(string s)` 的算法如下：

1. 读入字符串并丢弃无用的前导空格
2. 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
3. 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
4. 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 `0` 。必要时更改符号（从步骤 2 开始）。
5. 如果整数数超过 32 位有符号整数范围 `[−231, 231 − 1]` ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 `−231` 的整数应该被固定为 `−231` ，大于 `231 − 1` 的整数应该被固定为 `231 − 1` 。
6. 返回整数作为最终结果。

**注意：**

- 本题中的空白字符只包括空格字符 `' '` 。
- 除前导空格或数字后的其余字符串外，**请勿忽略** 任何其他字符。
## 题解
> 按照题目要求实现即可，注意细节
```java
public int myAtoi(String s) {  
    if (s.length() == 0) {  
        return 0;  
    }  
    final char[] chars = s.toCharArray();  
    int target = 0;  
    boolean negtive = false; // 是否负数  
    boolean symbol = false;  // 是否有符号位
    boolean start = false;  // 是否开始计数
    for (int i = 0; i < chars.length; i++) {  
        // 去除前导空格  
        if (!start && !symbol && chars[i] == ' ') {  
            continue;  
        } else if (!start && !symbol && chars[i] == '-') {  
            negtive = true; // 负数标记  
            symbol = true; // 符号标记  
            continue;  
        } else if (!start && !symbol && chars[i] == '+') {  
            symbol = true; // 符号标记  
            continue; // 正数标记  
        } else if (chars[i] >= '0' && chars[i] <= '9') {  
            // 数字处理  
            start = true;  
            int num = chars[i] - '0';  
            // 正数  
            if (!negtive) {  
                if ((Integer.MAX_VALUE - num) / 10 >= target) {  
                    target = target * 10 + num;  
                } else {  
                    return Integer.MAX_VALUE;  
                }  
            } else {  
                // 负数  
                if ((num - Integer.MIN_VALUE) / 10 <= -target) {  
                    target = target * 10 + num;  
                } else {  
                    return Integer.MIN_VALUE;  
                }  
            }  
        } else {  
            break;  
        }  
    }  
    return negtive ? -target : target;  
}
```
# 9.回文数
给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

- 例如，`121` 是回文，而 `123` 不是。
## 题解
- 方法一是转换为字符串，用双指针法判断是否是回文串  
- 方法二是翻转整数，看翻转后的结果是否与原数相同
```java
public boolean isPalindrome(int x) {  
    // 负数不是回文数  
    if (x < 0) {  
        return false;  
    }  
    int target = x % 10;  
    int tmp = x / 10;  
    while (tmp > 0) {  
        // 从右向左计数  
        target = target * 10 + tmp % 10;  
        // 更新除数  
        tmp = tmp / 10;  
    }  
    return x == target;  
}
```
# 13.罗马数字转整数
罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

**字符**          **数值**
I             1
V             5
X             10
L             50
C             100
D             500
M             1000

例如， 罗马数字 `2` 写做 `II` ，即为两个并列的 1 。`12` 写做 `XII` ，即为 `X` + `II` 。 `27` 写做 `XXVII`, 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。
- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。
## 题解
> 按顺序处理即可
```java
public int romanToInt(String s) {  
    final char[] chars = s.toCharArray();  
    int target = 0;  
    for (int i = 0; i < chars.length; i++) {  
        if (chars[i] == 'M') {  
            target += 1000;  
        } else if (chars[i] == 'D') {  
            target += 500;  
        } else if (chars[i] == 'C') {  
            if (i < chars.length - 1 && chars[i + 1] == 'D') {  
                target += 400;  
                i++;  
            } else if (i < chars.length - 1 && chars[i + 1] == 'M') {  
                target += 900;  
                i++;  
            } else {  
                target += 100;  
            }  
        } else if (chars[i] == 'L') {  
            target += 50;  
        } else if (chars[i] == 'X') {  
            if (i < chars.length - 1 && chars[i + 1] == 'L') {  
                target += 40;  
                i++;  
            } else if (i < chars.length - 1 && chars[i + 1] == 'C') {  
                target += 90;  
                i++;  
            } else {  
                target += 10;  
            }  
        } else if (chars[i] == 'V') {  
            target += 5;  
        } else if (chars[i] == 'I') {  
            if (i < chars.length - 1 && chars[i + 1] == 'V') {  
                target += 4;  
                i++;  
            } else if (i < chars.length - 1 && chars[i + 1] == 'X') {  
                target += 9;  
                i++;  
            } else {  
                target += 1;  
            }  
        }  
    }  
    return target;  
}
```
# 12.整数转罗马数字
罗马数字包含以下七种字符： `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

**字符**          **数值**
I             1
V             5
X             10
L             50
C             100
D             500
M             1000

例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做 `XXVII`, 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。
- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

给你一个整数，将其转为罗马数字。
## 题解
> 不同罗马数字代表不同的桶，按照大桶到小桶的顺序拆分填充组合
```java
public String intToRoman(int num) {  
    StringBuilder sb = new StringBuilder();  
    int tmp = num / 1000;  
    if (tmp > 0) {  
        for (int i = 0; i < tmp; i++) {  
            sb.append('M');  
        }  
    }  
    tmp = num % 1000;  
    if (tmp >= 900) {  
        sb.append("CM");  
        tmp -= 900;  
    }  
    if (tmp >= 500) {  
        sb.append('D');  
        tmp -= 500;  
    }  
    if (tmp >= 400) {  
        sb.append("CD");  
        tmp -= 400;  
    }  
    if (tmp >= 100) {  
        for (int i = 0; i < tmp / 100; i++) {  
            sb.append('C');  
        }  
        tmp %= 100;  
    }  
    if (tmp >= 90) {  
        sb.append("XC");  
        tmp -= 90;  
    }  
    if (tmp >= 50) {  
        sb.append('L');  
        tmp -= 50;  
    }  
    if (tmp >= 40) {  
        sb.append("XL");  
        tmp -= 40;  
    }  
    if (tmp >= 10) {  
        for (int i = 0; i < tmp / 10; i++) {  
            sb.append('X');  
        }  
        tmp %= 10;  
    }  
    if (tmp == 9) {  
        sb.append("IX");  
        tmp -= 9;  
    }  
    if (tmp >= 5) {  
        sb.append('V');  
        tmp -= 5;  
    }  
    if (tmp == 4) {  
        sb.append("IV");  
        tmp -= 4;  
    }  
    for (int i = 0; i < tmp; i++) {  
        sb.append('I');  
    }  
    return sb.toString();  
}
```
