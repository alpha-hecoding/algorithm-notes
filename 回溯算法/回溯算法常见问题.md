# 77.组合
给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。
## 题解
> 举例，从4个数里选2个数，穷举如下  
> (1)选第一个数，然后从剩下的三个数里再选一个，得三个组合  
> (2)选第二个数，然后从剩下的两个数里再选一个，得两个组合  
> (3)选第三个数，然后从剩下的一个数里再选一个，得一个组合  
> (4)选第四个数，剩下的没有可选的  
```java
class Solution {  
  
    private List<List<Integer>> result = new ArrayList<>();  
    private LinkedList<Integer> current = new LinkedList<>();  
  
    /**  
     * 回溯操作  
     */  
    private void backtracing(int n, int k, int startIndex) {  
        // 当前结果满足要求，终止回溯  
        if (current.size() == k) {  
            result.add(new ArrayList<>(current));  
            return;  
        }  
        // 循环上界会逐渐收缩  
        for (int i = startIndex; i <= n - (k - current.size()) + 1; i++) {  
            current.add(i);  
            // 从起始位置的下一个位置递归  
            backTracing(n, k, i + 1);  
            // 递归结束，移除当前元素  
            current.removeLast();  
        }  
    }  
  
    public List<List<Integer>> combine(int n, int k) {  
        backTracing(n, k, 1);  
        return result;  
    }  
}
```
# 216.组合总和三
找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：  

- 只使用数字1到9
- 每个数字 **最多使用一次**

返回 _所有可能的有效组合的列表_ 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。  
## 题解
> 在77-组合的基础上，对已找到的路径求和  
```java
class Solution {  
  
    private List<List<Integer>> result = new ArrayList<>();  
    private LinkedList<Integer> paths = new LinkedList<>();  
  
    private void backtracing(int k, int targetSum, int sum, int startIndex) {  
        // 剪枝，都是正数，和已超出目标值  
        if (sum > targetSum) {  
            return;  
        }  
        if (paths.size() == k && sum == targetSum) {  
            result.add(new ArrayList<>(paths));  
            return;  
        }  
        // 只能从1-9中取数，要保证能取到k个数  
        for (int i = startIndex; i <= 9 - (k - paths.size()) + 1; i++) {  
            // 添加路径并求和  
            paths.add(i);  
            sum += i;  
            // 递归查找  
            backtracing(k, targetSum, sum, i + 1);  
            // 回溯  
            sum -= i;  
            paths.removeLast();  
        }  
    }  
  
    public List<List<Integer>> combinationSum3(int k, int n) {  
        backtracing(k, n, 0, 1);  
        return result;  
    }  
}
```
# 17.电话号码的字母组合
给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
## 题解
> 输入数字序列中每个数字对应多字符的全排列，即按层每层取一个  
```java
class Solution {  
  
    /**  
     * 数字对应字符串，使用数组下标表示数字  
     */  
    private String[] charMap = new String[] {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};  
  
    private List<String> result = new ArrayList<>();  
    private char[] paths; // 结果字符串，长度与输入字符串一致  
  
    /**  
     * 回溯  
     *  
     * @param chars 输入序列  
     * @param index 索引，代表在输入序列中的层级  
     */  
    private void backtracing(char[] chars, int index) {  
        // 达到最后一层，收集结果  
        if (index == chars.length) {  
            result.add(new String(paths));  
            return;  
        }  
        // 当前数字对应的字符串  
        String numToStr = charMap[chars[index] - '0'];  
        char[] cs = numToStr.toCharArray();  
        // 依次取每一层的字符  
        for (int i = 0; i < cs.length; i++) {  
            paths[index] = cs[i];  
            backtracing(chars, index + 1);  
        }  
    }  
  
    public List<String> letterCombinations(String digits) {  
        if ("".equals(digits)) {  
            return result;  
        }  
        char[] chars = digits.toCharArray();  
        paths = new char[chars.length];  
        backtracing(chars, 0);  
        return result;  
    }  
}
```
# 39.组合总和
给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。
## 题解
> 递归的思路比较简单，从数组中寻找剩余待查找数  
> 难点1：去重。需要对收集的结果去重  
> 难点2：剪枝。需要对不符合的路径提前剪掉  
```java
class Solution {  
  
    private List<List<Integer>> result = new ArrayList<>();  
    private LinkedList<Integer> paths = new LinkedList<>();  
  
    private void backtracing(int[] candidates, int target) {  
        // 目标值到0了，当前结果集符合要求  
        if (target == 0) {  
            result.add(new ArrayList<>(paths));  
            return;  
        }  
        for (int i = 0; i < candidates.length; i++) {  
            // 剪枝，当前数值已经超过目标值，则剩余元素均不符合要求  
            if (candidates[i] > target) {  
                break;  
            }  
            // 去重操作，如果当前值小于已收集路径中的最后一个值，说明在之前路径处理过，无需再次处理  
            if (paths.size() > 0 && candidates[i] < paths.peekLast()) {  
                continue;  
            }  
            paths.add(candidates[i]);  
            backtracing(candidates, target - candidates[i]);  
            paths.removeLast();  
        }  
    }  
  
    public List<List<Integer>> combinationSum(int[] candidates, int target) {  
        // 先排序，为去重和剪枝做准备  
        Arrays.sort(candidates);  
        backtracing(candidates, target);  
        return result;  
    }  
}
```
# 40.组合总数二
给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用 **一次** 。

**注意：解集不能包含重复的组合。**
## 题解
> 难点是结果集不能玩重复，抽象起来就是同一层的数字，有重复的需要跳过  
```java
class Solution {  
  
    private List<List<Integer>> result = new ArrayList<>();  
    private LinkedList<Integer> paths = new LinkedList<>();  
  
    private void backtracing(int[] candidates, int target, int startIndex) {  
        if (target == 0) {  
            result.add(new ArrayList<>(paths));  
            return;  
        }  
        for (int i = startIndex; i < candidates.length; i++) {  
            // 剪枝，已排序的数组元素已经大于目标值，则后续元素不需要考虑  
            if (candidates[i] > target) {  
                break;  
            }  
            // 本轮循环(同一层)中，重复数据跳过  
            if (i > startIndex && candidates[i] == candidates[i - 1]) {  
                continue;  
            }  
            paths.add(candidates[i]);  
            backtracing(candidates, target - candidates[i], i + 1);  
            paths.removeLast();  
        }  
    }  
  
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {  
        // 先排序  
        Arrays.sort(candidates);  
        backtracing(candidates, target, 0);  
        return result;  
    }  
}
```
# 131.分割回文串
给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串。
## 题解
