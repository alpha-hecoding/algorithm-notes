# 77.组合
给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。
## 题解
> 举例，从4个数里选2个数，穷举如下  
> (1)选第一个数，然后从剩下的三个数里再选一个，得三个组合  
> (2)选第二个数，然后从剩下的两个数里再选一个，得两个组合  
> (3)选第三个数，然后从剩下的一个数里再选一个，得一个组合  
> (4)选第四个数，剩下的没有可选的  
```java
class Solution {  
  
    private List<List<Integer>> result = new ArrayList<>();  
    private LinkedList<Integer> current = new LinkedList<>();  
  
    /**  
     * 回溯操作  
     */  
    private void backtracing(int n, int k, int startIndex) {  
        // 当前结果满足要求，终止回溯  
        if (current.size() == k) {  
            result.add(new ArrayList<>(current));  
            return;  
        }  
        // 循环上界会逐渐收缩  
        for (int i = startIndex; i <= n - (k - current.size()) + 1; i++) {  
            current.add(i);  
            // 从起始位置的下一个位置递归  
            backTracing(n, k, i + 1);  
            // 递归结束，移除当前元素  
            current.removeLast();  
        }  
    }  
  
    public List<List<Integer>> combine(int n, int k) {  
        backTracing(n, k, 1);  
        return result;  
    }  
}
```
# 216.组合总和三
找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：  

- 只使用数字1到9
- 每个数字 **最多使用一次**

返回 _所有可能的有效组合的列表_ 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。  
## 题解
> 在77-组合的基础上，对已找到的路径求和  
```java
class Solution {  
  
    private List<List<Integer>> result = new ArrayList<>();  
    private LinkedList<Integer> paths = new LinkedList<>();  
  
    private void backtracing(int k, int targetSum, int sum, int startIndex) {  
        // 剪枝，都是正数，和已超出目标值  
        if (sum > targetSum) {  
            return;  
        }  
        if (paths.size() == k && sum == targetSum) {  
            result.add(new ArrayList<>(paths));  
            return;  
        }  
        // 只能从1-9中取数，要保证能取到k个数  
        for (int i = startIndex; i <= 9 - (k - paths.size()) + 1; i++) {  
            // 添加路径并求和  
            paths.add(i);  
            sum += i;  
            // 递归查找  
            backtracing(k, targetSum, sum, i + 1);  
            // 回溯  
            sum -= i;  
            paths.removeLast();  
        }  
    }  
  
    public List<List<Integer>> combinationSum3(int k, int n) {  
        backtracing(k, n, 0, 1);  
        return result;  
    }  
}
```
# 17.电话号码的字母组合
给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
## 题解
> 输入数字序列中每个数字对应多字符的全排列，即按层每层取一个  
```java
class Solution {  
  
    /**  
     * 数字对应字符串，使用数组下标表示数字  
     */  
    private String[] charMap = new String[] {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};  
  
    private List<String> result = new ArrayList<>();  
    private char[] paths; // 结果字符串，长度与输入字符串一致  
  
    /**  
     * 回溯  
     *  
     * @param chars 输入序列  
     * @param index 索引，代表在输入序列中的层级  
     */  
    private void backtracing(char[] chars, int index) {  
        // 达到最后一层，收集结果  
        if (index == chars.length) {  
            result.add(new String(paths));  
            return;  
        }  
        // 当前数字对应的字符串  
        String numToStr = charMap[chars[index] - '0'];  
        char[] cs = numToStr.toCharArray();  
        // 依次取每一层的字符  
        for (int i = 0; i < cs.length; i++) {  
            paths[index] = cs[i];  
            backtracing(chars, index + 1);  
        }  
    }  
  
    public List<String> letterCombinations(String digits) {  
        if ("".equals(digits)) {  
            return result;  
        }  
        char[] chars = digits.toCharArray();  
        paths = new char[chars.length];  
        backtracing(chars, 0);  
        return result;  
    }  
}
```
# 39.组合总和
给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。
## 题解
> 递归的思路比较简单，从数组中寻找剩余待查找数  
> 难点1：去重。需要对收集的结果去重  
> 难点2：剪枝。需要对不符合的路径提前剪掉  
```java
class Solution {  
  
    private List<List<Integer>> result = new ArrayList<>();  
    private LinkedList<Integer> paths = new LinkedList<>();  
  
    private void backtracing(int[] candidates, int target) {  
        // 目标值到0了，当前结果集符合要求  
        if (target == 0) {  
            result.add(new ArrayList<>(paths));  
            return;  
        }  
        for (int i = 0; i < candidates.length; i++) {  
            // 剪枝，当前数值已经超过目标值，则剩余元素均不符合要求  
            if (candidates[i] > target) {  
                break;  
            }  
            // 去重操作，如果当前值小于已收集路径中的最后一个值，说明在之前路径处理过，无需再次处理  
            if (paths.size() > 0 && candidates[i] < paths.peekLast()) {  
                continue;  
            }  
            paths.add(candidates[i]);  
            backtracing(candidates, target - candidates[i]);  
            paths.removeLast();  
        }  
    }  
  
    public List<List<Integer>> combinationSum(int[] candidates, int target) {  
        // 先排序，为去重和剪枝做准备  
        Arrays.sort(candidates);  
        backtracing(candidates, target);  
        return result;  
    }  
}
```
# 40.组合总数二
给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用 **一次** 。

**注意：解集不能包含重复的组合。**
## 题解
> 难点是结果集不能玩重复，抽象起来就是同一层的数字，有重复的需要跳过  
```java
class Solution {  
  
    private List<List<Integer>> result = new ArrayList<>();  
    private LinkedList<Integer> paths = new LinkedList<>();  
  
    private void backtracing(int[] candidates, int target, int startIndex) {  
        if (target == 0) {  
            result.add(new ArrayList<>(paths));  
            return;  
        }  
        for (int i = startIndex; i < candidates.length; i++) {  
            // 剪枝，已排序的数组元素已经大于目标值，则后续元素不需要考虑  
            if (candidates[i] > target) {  
                break;  
            }  
            // 本轮循环(同一层)中，重复数据跳过  
            if (i > startIndex && candidates[i] == candidates[i - 1]) {  
                continue;  
            }  
            paths.add(candidates[i]);  
            backtracing(candidates, target - candidates[i], i + 1);  
            paths.removeLast();  
        }  
    }  
  
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {  
        // 先排序  
        Arrays.sort(candidates);  
        backtracing(candidates, target, 0);  
        return result;  
    }  
}
```
# 131.分割回文串
给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串。
## 题解
> 很容易想到递归：先拆出一个回文串，再继续把剩余子串拆分
```java
class Solution {  
  
    private List<List<String>> result = new ArrayList<>();  
    private LinkedList<String> splitList = new LinkedList<>();  
  
    /**  
     * 判断给定区间部分[start,end)是否是回文串  
     */  
    private boolean isPalindrome(char[] chars, int start, int end) {  
        if (start >= end) {  
            return false;  
        }  
        while (start < end && chars[start] == chars[end - 1]) {  
            start++;  
            end--;  
        }  
        return start >= end;  
    }  
  
    /**  
     * 按区间[start,end)取子串  
     */  
    private String buildString(char[] chars, int start, int end) {  
        char[] cs = new char[end - start];  
        System.arraycopy(chars, start, cs, 0, end - start);  
        return new String(cs);  
    }  
  
    private void backtracing(char[] chars, int start, int end) {  
        // 已经到了末尾  
        if (start >= chars.length) {  
            result.add(new ArrayList<>(splitList));  
            return;  
        }  
        for (int i = start; i < chars.length; i++) {  
            // 当前子串是回文串，则继续拆分剩余子串  
            if (isPalindrome(chars, start, i + 1)) {  
                splitList.add(buildString(chars, start, i + 1));  
                backtracing(chars, i + 1, chars.length);  
                splitList.removeLast();  
            }  
        }  
    }  
  
    public List<List<String>> partition(String s) {  
        final char[] chars = s.toCharArray();  
        backtracing(chars, 0, chars.length);  
        return result;  
    }  
}
```
# 93.复原ip地址
**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。  

- 例如：`"0.1.2.201"` 和 `"192.168.1.1"` 是 **有效** IP 地址，但是 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 **无效** IP 地址。  

给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。  
## 题解
> 将字符串切割为4个分段，每个分段不能含前导0且不能超过255
```java
class Solution {  
  
    private List<String> result = new ArrayList<>();  
    private String[] ip = new String[4];  
  
    private void backtracing(String s, int index, int startIndex) {  
        if (index == 4) {  
            result.add(String.join(".", ip));  
            return;  
        }  
        for (int i = startIndex; i < s.length(); i++) {  
            // 最后一段取剩余所有字符  
            if (index == 3 && i < s.length() - 1) {  
                continue;  
            }  
            // 当前分段  
            String subsection = s.substring(startIndex, i + 1);  
            // 排除0开头的，或超过255的，注意可能数据超限，需要对当前超过255时剪枝  
            if ((subsection.length() > 1 && subsection.startsWith("0"))  
                    || i - startIndex > 2 || Integer.parseInt(subsection) > 255) {  
                break;  
            }  
            ip[index] = subsection;  
            // 拆分下一个分段  
            backtracing(s, index + 1, i + 1);  
        }  
    }  
  
    public List<String> restoreIpAddresses(String s) {  
        backtracing(s, 0, 0);  
        return result;  
    }  
}
```
# 78.子集
给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。  

**示例 1：**

**输入：** nums = [1,2,3]
**输出：** \[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

**示例 2：**

**输入：** nums = [0]
**输出：** \[[],[0]]
## 题解
> 子集大小为`0~数组大小`，遍历过程中直接收集，直到遍历到数组尾部   
```java
class Solution {  
  
    private List<List<Integer>> result = new ArrayList<>();  
    private LinkedList<Integer> paths = new LinkedList<>();  
  
    /**  
     * 回溯  
     *  
     * @param nums       数组  
     * @param startIndex 子集下一个元素在原数组中的起始位置  
     */  
    private void backtracing(int[] nums, int startIndex) {  
        result.add(new ArrayList<>(paths)); // 直接收集结果  
        // 结束条件：起始位置超过数组长度  
        if (startIndex >= nums.length) {  
            return;  
        }  
        for (int i = startIndex; i < nums.length; i++) {  
            paths.add(nums[i]);  
            backtracing(nums, i + 1);  
            paths.removeLast();  
        }  
    }  
  
    public List<List<Integer>> subsets(int[] nums) {  
        backtracing(nums, 0);  
        return result;  
    }  
}
```
# 90.子集二
给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。

**示例 1：**

**输入：** nums = [1,2,2]
**输出：** \[[],[1],[1,2],[1,2,2],[2],[2,2]]

**示例 2：**

**输入：** nums = [0]
**输出：** \[[],[0]]
## 题解
> 在78题的基础上需要添加去重逻辑，通常思路是先对数组排序，相同数据位置相邻，依据这一特性去重 
```java
class Solution {  
  
    private List<List<Integer>> result = new ArrayList<>();  
    private LinkedList<Integer> paths = new LinkedList<>();  
  
    private void backtracing(int[] nums, int startIndex) {  
        result.add(new ArrayList<>(paths)); // 直接收集结果  
        // 结束条件：起始位置超过数组长度  
        if (startIndex >= nums.length) {  
            return;  
        }  
        for (int i = startIndex; i < nums.length; i++) {  
            // 去重操作，非起始位置的与前一位置相同的元素在之前已经被收集过  
            if (i > startIndex && nums[i] == nums[i - 1]) {  
                continue;  
            }  
            paths.add(nums[i]);  
            backtracing(nums, i + 1);  
            paths.removeLast();  
        }  
    }  
  
    public List<List<Integer>> subsetsWithDup(int[] nums) {  
        Arrays.sort(nums); // 先排序，便于去重  
        backtracing(nums, 0);  
        return result;  
    }  
}
```
# 491.递增子序列
给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

**示例 1：**

**输入：** nums = [4,6,7,7]
**输出：** \[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]

**示例 2：**

**输入：** nums = [4,4,3,2,1]
**输出：** \[[4,4]]
## 题解
- 不可以对数组排序，因为排序会打乱原有顺序
- 要保证所求结果子序列的递增
- 单层元素需要去重，可使用hash
```java
class Solution {  
  
    private List<List<Integer>> result = new ArrayList<>();  
    private LinkedList<Integer> paths = new LinkedList<>();  
  
    private void backtracing(int[] nums, int startIndex) {  
        // 子序列中至少包含2个元素  
        if (paths.size() >= 2) {  
            result.add(new ArrayList<>(paths));  
        }  
        // 利用hashset来对本层处理过的数据去重，根据数组元素范围，可以使用数组或位数组模拟hash  
        Set<Integer> set = new HashSet<>();  
        for (int i = startIndex; i < nums.length; i++) {  
            // 保证递增，同时对同一层处理过的元素去重  
            if ((!paths.isEmpty() && nums[i] < paths.peekLast()) || set.contains(nums[i])) {  
                continue;  
            }  
            set.add(nums[i]); // 记录每一层使用过的元素  
            paths.add(nums[i]);  
            backtracing(nums, i + 1);  
            paths.removeLast();  
        }  
    }  
  
    public List<List<Integer>> findSubsequences(int[] nums) {  
        backtracing(nums, 0);  
        return result;  
    }  
}
```
# 46.全排列
给定一个不含重复数字的数组 `nums` ，返回其 _所有可能的全排列_ 。你可以 **按任意顺序** 返回答案。

**示例 1：**

**输入：** nums = [1,2,3]
**输出：** \[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
## 题解
- 每个排列都包含所有元素
- 每次选取元素都要排除已选元素后剩余元素中选
```java
class Solution {  
  
    private List<List<Integer>> result = new ArrayList<>();  
    private LinkedHashSet<Integer> paths = new LinkedHashSet<>();  
  
    private void backtracing(int[] nums) {  
        // 收集数据达到数组元素个数时，即每个元素都收集了一次，则结束收集  
        if (paths.size() == nums.length) {  
            result.add(new ArrayList<>(paths));  
            return;  
        }  
        // 每一层都是排除已收集的元素，从剩下元素中选一个  
        for (int i = 0; i < nums.length; i++) {  
            if (!paths.contains(nums[i])) {  
                paths.add(nums[i]);  
                backtracing(nums);  
                paths.remove(nums[i]);  
            }  
        }  
    }  
  
    public List<List<Integer>> permute(int[] nums) {  
        backtracing(nums);  
        return result;  
    }  
}
```
# 47.全排列二
给定一个可包含重复数字的序列 `nums` ，_**按任意顺序**_ 返回所有不重复的全排列。

**示例 1：**

**输入：** nums = [1,1,2]
**输出：**
\[[1,1,2],
 [1,2,1],
 [2,1,1]]

**示例 2：**

**输入：** nums = [1,2,3]
**输出：** \[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
## 题解
- 去重是关键。先对元素排序，同一层中相邻相同元素，前一个元素使用过则跳过
- 存在重复元素，判断使用过使用数组下标
### 重点理解去重逻辑
- `used[i-1]==true`，表示本次路径中已收集，肯定不是在这一层收集的，是对树枝去重
- `used[i-1]==false`，表示本次路径中未收集，肯定是在其它树枝收集本层时收集过，是对树层去重
```java
class Solution {  
  
    private List<List<Integer>> result = new ArrayList<>();  
    private LinkedList<Integer> paths = new LinkedList<>();  
    private boolean[] used;  
  
    private void backtracing(int[] nums) {  
        // 收集数据达到数组元素个数时，即每个元素都收集了一次，则结束收集  
        if (paths.size() == nums.length) {  
            result.add(new ArrayList<>(paths));  
            return;  
        }  
        for (int i = 0; i < nums.length; i++) {  
            // 检测数组下标是否使用过  
            if (used[i]) {  
                continue;  
            }  
            // 去重：同一层相同数值元素，且前一个元素使用过，则跳过  
            // used[i-1]==true，表示本次路径中已收集，肯定不是在这一层收集的，是对树枝去重  
            // used[i-1]==false，表示本次路径中未收集，肯定是在其它树枝收集本层时收集过，是对树层去重  
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {  
                continue;  
            }  
            paths.add(nums[i]); // 添加到路径  
            used[i] = true; // 标记使用  
            backtracing(nums); // 递归  
            paths.removeLast(); // 清理  
            used[i] = false; // 清除使用标记  
        }  
    }  
  
    public List<List<Integer>> permuteUnique(int[] nums) {  
        Arrays.sort(nums);  
        used = new boolean[nums.length];  
        backtracing(nums);  
        return result;  
    }  
}
```
# 332.重新安排行程
给你一份航线列表 `tickets` ，其中 `tickets[i] = [fromi, toi]` 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。

所有这些机票都属于一个从 `JFK`（肯尼迪国际机场）出发的先生，所以该行程必须从 `JFK` 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。

- 例如，行程 `["JFK", "LGA"]` 与 `["JFK", "LGB"]` 相比就更小，排序更靠前。

假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。
## 题解
> 最终结果需要按照字典序排序，可以先将机票按照到达机场排序，符合条件的路径自然会符合排序要求 
- 找到的路径节点数为机票数+1时，表示所有机票都用到了，结束寻找  
- 寻找过程依然是每次从剩下机票中寻找合适的，需要标记已使用的机票
- 当机票不符合条件时需要回退继续查找下一个可能得路径
### 纯暴力搜索方法
```java
class Solution {  
  
    private List<String> result = new ArrayList<>();  
    private LinkedList<String> path = new LinkedList<>();  
    private boolean[] used;  
  
    private boolean backtracing(List<List<String>> tickets) {  
        // 路径数为票据数+1  
        if (path.size() == tickets.size() + 1) {  
            result = new ArrayList<>(path);  
            return true;  
        }  
        for (int i = 0; i < tickets.size(); i++) {  
            if (used[i]) {  
                continue;  
            }  
            final String last = path.peekLast();  
            if (last.equals(tickets.get(i).get(0))) {  
                path.add(tickets.get(i).get(1)); // 添加到路径  
                used[i] = true; // 标记为使用  
                // 从剩余机票中查找，直到所有机票已使用，符合条件时直接结束  
                if (backtracing(tickets)) {  
                    return true;  
                }  
                // 当前所找路径未使用完所有机票，回退时寻找其它路径  
                path.removeLast();  
                used[i] = false;  
            }  
        }  
        return false;  
    }  
  
    public List<String> findItinerary(List<List<String>> tickets) {  
        // 按到达机场排序  
        tickets.sort(Comparator.comparing(l -> l.get(1)));  
        path.add("JFK"); // 首个出发机场是JFK  
        used = new boolean[tickets.size()]; // 使用标记  
        backtracing(tickets);  
        return result;  
    }  
}
```
# 51.N皇后问题
按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。
## 题解
> 简化为每一行中寻找一个位置，该位置在之前行中不能是皇后，且需要处理斜线
```java
class Solution {  
  
    private List<List<String>> result = new ArrayList<>();  
    private char[][] path;  
  
    /**  
     * 回溯处理  
     *  
     * @param n       总层数（行数）  
     * @param k       当前处理层数（行号）  
     * @param exclude 当前需要排除的列号  
     */  
    private void backtracing(int n, int k, Set<Integer> exclude) {  
        if (k == n) {  
            List<String> list = new ArrayList<>();  
            for (char[] chars : path) {  
                list.add(new String(chars));  
            }  
            result.add(list);  
            return;  
        }  
        // 对第k行查找皇后位置  
        for (int j = 0; j < n; j++) {  
            // 当前列已被使用，需排除  
            if (exclude.contains(j)) {  
                continue;  
            }  
            // 当前位置是(行=k,列=j)  
            boolean match = true; // 是否匹配  
            // 斜线处理，左上位置(行=k-1,列=j-1)  
            for (int x = k - 1, y = j - 1; x >= 0 && y >= 0; x--, y--) {  
                if (path[x][y] == 'Q') {  
                    match = false;  
                    break;  
                }  
            }  
            if (!match) {  
                continue;  
            }  
            // 斜线处理，右上位置(行=k-1,列=j+1)  
            for (int x = k - 1, y = j + 1; x >= 0 && y <= n - 1; x--, y++) {  
                if (path[x][y] == 'Q') {  
                    match = false;  
                    break;  
                }  
            }  
            if (!match) {  
                continue;  
            }  
            // 当前位置赋值为Q，寻找下一行  
            path[k][j] = 'Q';  
            exclude.add(j);  
            backtracing(n, k + 1, exclude);  
            // 回溯处理，恢复当前位置为.  
            path[k][j] = '.';  
            exclude.remove(j);  
        }  
    }  
  
    public List<List<String>> solveNQueens(int n) {  
        path = new char[n][n];  
        // 初始化  
        for (int i = 0; i < n; i++) {  
            for (int j = 0; j < n; j++) {  
                path[i][j] = '.';  
            }  
        }  
        backtracing(n, 0, new HashSet<>());  
        return result;  
    }  
}
```
# 37.解数独
编写一个程序，通过填充空格来解决数独问题。

数独的解法需 **遵循如下规则**：

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

数独部分空格内已填入了数字，空白格用 `'.'` 表示。
## 题解
- 找到空位依次尝试9个数字，判断填入该数字后是否符合行、列、九宫格内不重复条件
- 符合条件后递归处理其它空白处
- 9个数字都尝试完依然不符合，则可以直接结束 
```java
class Solution {  
  
    /**  
     * 判断一个空位是否可以设置为指定数字  
     *  
     * @param row   行  
     * @param col   列  
     * @param val   值  
     * @param board 板  
     */  
    private boolean isValid(int row, int col, char val, char[][] board) {  
        if (board[row][col] == val) {  
            return true;  
        }  
        // 判断同行是否有该数字  
        for (int i = 0; i < 9; i++) {  
            if (board[row][i] == val) {  
                return false;  
            }  
        }  
        // 判断同列是否有该数字  
        for (int i = 0; i < 9; i++) {  
            if (board[i][col] == val) {  
                return false;  
            }  
        }  
        // 判断该位置的九宫格内是否已有该数字  
        int rowStart = (row / 3) * 3;  
        int colStart = (col / 3) * 3;  
        for (int i = rowStart; i < rowStart + 3; i++) {  
            for (int j = colStart; j < colStart + 3; j++) {  
                if (board[i][j] == val) {  
                    return false;  
                }  
            }  
        }  
        return true;  
    }  
  
    private boolean backtracing(char[][] board) {  
        for (int i = 0; i < 9; i++) {  
            for (int j = 0; j < 9; j++) {  
                // 需要填充数字处理  
                if (board[i][j] == '.') {  
                    // 依次拿9个数字去尝试填充  
                    for (char k = '1'; k <= '9'; k++) {  
                        if (isValid(i, j, k, board)) {  
                            board[i][j] = k; // 当前位置可以填入k，则填入  
                            if (backtracing(board)) {  
                                return true; // 剩下位置也填充OK，则直接返回  
                            }  
                            board[i][j] = '.'; // 当前位置填充k导致剩下位置填充失败，则回溯  
                        }  
                    }  
                    // 9个数字都试完了，则找不到合适的数字  
                    return false;  
                }  
            }  
        }  
        return true;  
    }  
  
    public void solveSudoku(char[][] board) {  
        backtracing(board);  
    }  
}
```