# 344.反转字符串
> 双指针法前后交换
```java
public void reverseString(char[] s) {  
    int i = 0;  
    int j = s.length - 1;  
    while (j > i) {  
        char c = s[i];  
        s[i] = s[j];  
        s[j] = c;  
        i++;  
        j--;  
    }  
}
```
# 541.反转字符串二
给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。 
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。
> 按2k个长度分组，对前k个反转，细节是处理最后不满足2k长度的子串
```java
public void reverse(char[] cs, int start, int end) {  
    // 对字符数组的[start,end)区间内字符反转  
    end--;  
    while (end > start) {  
        char c = cs[end];  
        cs[end] = cs[start];  
        cs[start] = c;  
        start++;  
        end--;  
    }  
}  
  
public String reverseStr(String s, int k) {  
    final char[] chars = s.toCharArray();  
    for (int i = 0; i < chars.length; i += 2 * k) {  
        reverse(chars, i, i + k >= chars.length ? chars.length : i + k);  
    }  
    return new String(chars);  
}
```
# 151.翻转字符串里的单词
给定一个字符串，逐个翻转字符串中的每个单词。

示例 1：  
输入: "the sky is blue"  
输出: "blue is sky the"

示例 2：  
输入: "  hello world!  "  
输出: "world! hello"  
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
> 先整体翻转一遍，然后逐个翻转单词，即符合要求  
> 去除空格采用双指针的方法  
> 细节问题是单词之间拼接空格，建议是在从第二个单词开始每个单词之前处理，避免消除尾部多余空格  
```java
public void reverse(char[] cs, int start, int end) {  
    // 对字符数组的[start,end)区间内字符反转  
    end--;  
    while (end > start) {  
        char c = cs[end];  
        cs[end] = cs[start];  
        cs[start] = c;  
        start++;  
        end--;  
    }  
}  
  
public String reverseWords(String s) {  
    final char[] chars = s.toCharArray();  
    reverse(chars, 0, chars.length);  
    int slow = 0;  
    int fast = 0;  
    int start = 0;  
    while (fast < chars.length) {  
        // 跳过空格，找到第一个非空字符位置  
        while (fast < chars.length && chars[fast] == ' ') {  
            fast++;  
        }  
        if (fast == chars.length) {  
            break;  
        }  
        // 单词起始位置  
        start = slow;  
        // 非首个单词拼接空格，单词首位也前进一位  
        if (start > 0) {  
            chars[slow++] = ' ';  
            start++;  
        }  
        while (fast < chars.length && chars[fast] != ' ') {  
            // 拷贝字符  
            chars[slow++] = chars[fast++];  
        }  
        // 单词结束，反转单词,slow指向单词结束位置的后一位  
        reverse(chars, start, slow);  
    }  
    // 组成新的字符串，区间[0,slow)  
    char[] newChars = new char[slow];  
    for (int i = 0; i < slow; i++) {  
        newChars[i] = chars[i];  
    }  
    return new String(newChars);  
}
```
# 459.重复的子字符串
给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。    
示例 1:

- 输入: "abab"
- 输出: True
- 解释: 可由子字符串 "ab" 重复两次构成。
## 题解
> 如果是重复子串组成的字符串，按照KMP算法，求出其最大相等前后缀，与原字符串相差的部分即是重复的子串。再遍历该字符是否由该子串重复组成即可。
```java
private int[] getNext(char[] cs) {  
    int[] next = new int[cs.length];  
    int j = 0;  
    int i = 1;  
    for (; i < cs.length; i++) {  
        while (j > 0 && cs[i] != cs[j]) {  
            j = next[j - 1];  
        }  
        if (cs[i] == cs[j]) {  
            next[i] = j + 1;  
            j++;  
        }  
    }  
    return next;  
}  
  
public boolean repeatedSubstringPattern(String s) {  
    if (s.length() <= 1) {  
        return false;  
    }  
    // 求取kmp算法的next数组  
    final char[] cs = s.toCharArray();  
    final int[] next = getNext(cs);  
    final int max = next[cs.length - 1];  
    if (max == 0) {  
        return false;  
    }  
    final int subLen = cs.length - max;  
    if (cs.length % subLen != 0) {  
        return false;  
    }  
    for (int i = 0; i < cs.length; i += subLen) {  
        for (int j = 0; j < subLen; j++) {  
            if (cs[i + j] != cs[j]) {  
                return false;  
            }  
        }  
    }  
    return true;  
}
```