**本文大部分参考[卡尔大神代码随想录]([代码随想录 (programmercarl.com)](https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE))的KMP讲解内容。**  

KMP的经典思想就是:**当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。**
### KMP有什么用
KMP主要应用在字符串匹配上。

KMP的主要思想是**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。**

所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。
### 什么是前缀表
写过KMP的同学，一定都写过next数组，那么这个next数组究竟是个啥呢？

next数组就是一个前缀表（prefix table）。

前缀表有什么作用呢？

**前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。**

为了清楚地了解前缀表的来历，我们来举一个例子：

要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。
如动画所示：

![KMP详解1](https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif)
动画里，我特意把 子串`aa` 标记上了，这是有原因的，大家先注意一下，后面还会说到。

可以看出，文本串中第六个字符b 和 模式串的第六个字符f，不匹配了。如果暴力匹配，发现不匹配，此时就要从头匹配了。

但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中第三个字符b继续开始匹配。

此时就要问了**前缀表是如何记录的呢？**

首先要知道前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。

那么什么是前缀表：**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**
### 最长公共前后缀

文章中字符串的**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串**。

**后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。

**正确理解什么是前缀什么是后缀很重要**!

那么网上清一色都说 “kmp 最长公共前后缀” 又是什么回事呢？

我查了一遍 算法导论 和 算法4里KMP的章节，都没有提到 “最长公共前后缀”这个词，也不知道从哪里来了，我理解是用“最长相等前后缀” 更准确一些。

**因为前缀表要求的就是相同前后缀的长度。**

而最长公共前后缀里面的“公共”，更像是说前缀和后缀公共的长度。这其实并不是前缀表所需要的。

所以字符串a的最长相等前后缀为0。 字符串aa的最长相等前后缀为1。 字符串aaa的最长相等前后缀为2。 等等.....。

### 为什么一定要用前缀表

这就是前缀表，那为啥就能告诉我们 上次匹配的位置，并跳过去呢？

回顾一下，刚刚匹配的过程在下标5的地方遇到不匹配，模式串是指向f，如图： ![KMP精讲1](https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B21.png)

然后就找到了下标2，指向b，继续匹配：如图： ![KMP精讲2](https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B22.png)

以下这句话，对于理解为什么使用前缀表可以告诉我们匹配失败之后跳到哪里重新匹配 非常重要！

**下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。**

所以前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。

**很多介绍KMP的文章或者视频并没有把为什么要用前缀表？这个问题说清楚，而是直接默认使用前缀表。**

### 如何计算前缀表

接下来就要说一说怎么计算前缀表。

如图：

![KMP精讲5](https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B25.png)

长度为前1个字符的子串`a`，最长相同前后缀的长度为0。（注意字符串的**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串**；**后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。）

![KMP精讲6](https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B26.png)

长度为前2个字符的子串`aa`，最长相同前后缀的长度为1。

![KMP精讲7](https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B27.png)

长度为前3个字符的子串`aab`，最长相同前后缀的长度为0。

以此类推： 长度为前4个字符的子串`aaba`，最长相同前后缀的长度为1。 长度为前5个字符的子串`aabaa`，最长相同前后缀的长度为2。 长度为前6个字符的子串`aabaaf`，最长相同前后缀的长度为0。

那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图： ![KMP精讲8](https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B28.png)

可以看出模式串与前缀表对应位置的数字表示的就是：**下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**

再来看一下如何利用 前缀表找到 当字符不匹配的时候应该指针应该移动的位置。如动画所示：

![KMP精讲2](https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B22.gif)

找到的不匹配的位置， 那么此时我们要看它的前一个字符的前缀表的数值是多少。

为什么要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀。

所以要看前一位的 前缀表的数值。

前一个字符的前缀表的数值是2， 所以把下标移动到下标2的位置继续比配。 可以再反复看一下上面的动画。

最后就在文本串中找到了和模式串匹配的子串了。

### 前缀表与next数组

很多KMP算法的实现都是使用next数组来做回退操作，那么next数组与前缀表有什么关系呢？

next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。

为什么这么做呢，其实也是很多文章视频没有解释清楚的地方。

其实**这并不涉及到KMP的原理，而是具体实现，next数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。**

后面我会提供两种不同的实现代码，大家就明白了。

### 使用next数组来匹配

**以下我们以前缀表统一减一之后的next数组来做演示**。

有了next数组，就可以根据next数组来 匹配文本串s，和模式串t了。

注意next数组是新前缀表（旧前缀表统一减一了）。

匹配过程动画如下：

![KMP精讲4](https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B24.gif)

### 时间复杂度分析

其中n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)的。

暴力的解法显而易见是O(n × m)，所以**KMP在字符串匹配中极大地提高了搜索的效率。**

为了和力扣题目28.实现strStr保持一致，方便大家理解，以下文章统称haystack为文本串, needle为模式串。

都知道使用KMP算法，一定要构造next数组。

### 构造next数组
**构造next数组其实就是计算模式串s，前缀表的过程。**
主要有如下三步：

1. 初始化
2. 处理前后缀不相同的情况
3. 处理前后缀相同的情况

> 首先不急于如何计算，先大概分析下，找找规律。  
- next数组的每一位代表模式串从起始位置到该位置的子串的最大相等前后缀的长度，以模式串`aabaaf`为例，结果如下

|下标|子串|最长相等前后缀|前缀区间|后缀区间|next数组值|
|:--|:--|:--|:--|:--|--:|
|0|a||||0|
|1|aa|a|[0,0]|[1,1]|1|
|2|aab||||0|
|3|aaba|a|[0,0]|[3,3]|1|
|4|aabaa|aa|[0,1]|[3,4]|2|
|5|aabaaf||||0|

- 过程是依次查找各子串的最大相等前后缀，即当前子串后缀与前缀重合度，下面来分析查找的过程中的规律
> (1)以子串`aaba`为例，找到最大相等前后缀为a，前缀为[0,0]，长度为1，后缀为[3,3]；    
> (2)假定用`i`表示当前子串的末尾位置，也即后缀位置，用`j`表示正在寻找的前缀的末尾位置，如果找到，那么next[i]=j+1，即**最大相等前后缀长度等于前缀末尾下标+1**；
```
子串: aaba
前缀: 末尾下标j=0, [0,0] => a
后缀: 末尾下标i=3, [3,3] => a
next: next[i] = j + 1 = 1
```
> (3)当子串扩大一位即`aabaa`时，无需从头开始匹配，在上次的基础上前后缀下标都向前移一位，**如果两个移位的字符相等**，则说明当前子串的最大相等前后缀必然是**前一个子串的最大相等前后缀扩大一位**后的结果，即`next[i]=next[i-1]+1`；  
```
子串: aabaa
前子串的最大相等前后缀: a
前缀: 末尾下标j=1, [0,1] => aa, 上一次前缀的基础上后移一位
后缀: 末尾下标i=4
前后缀末尾相等，因为在上一轮中前后缀已经相等，因此本轮中前后缀+1
next: next[i] = next[i-1] + 1 = j + 1 = 2
```
> (4)当子串再扩大一位即`aabaaf`时，在上次的基础上前后缀下标都向前移一位，**两个移位的字符不相等**，参照KMP匹配规则，不相等则回到模式串前一个位置(即上一个前缀[0,j-1])的next数组值(即回退到其最长相等前后缀长度，也即最长相等前后缀中的前缀的后一位)重新比较，则前缀末尾位置回到next[j-1]，即j=next[j-1]，如此循环回退，直到回退到初始位置或前缀末尾与当前后缀末尾相等；
```
子串: aabaaf
前子串的最大相等前后缀: aa
前缀: 末尾下标j=2, [0,2] => aab, 上一次前缀的基础上后移一位
后缀: 末尾下标i=5
子串A => xxxx a a f           =>              xxxx a a f
模式串B =>    a a b    回退（模式串前移） =>         a a b
上一轮的前缀区间: [0,j-1] => [0,1]
上一轮的后缀区间: [i-1-next[i-1],i-1] => [3,4]
已知B[0,j-1] = A[i-1-next[i-1],i-1]，此时B[j] != A[i], 则前缀区间缩小到[0,next[j-1]]=[0,l]
```
- 因此可以写出如下求解next数组的方法
```java
private static int[] getNext(char[] cs) {  
    int[] next = new int[cs.length];  
    int j = 0; // 前缀末尾，第一个字符无前缀，初始为0  
    int i = 1; // 后缀末尾，第一个字符无后缀，因此从1开始  
    for (; i < cs.length; i++) {  
        if (cs[i] == cs[j]) {  
            // 前缀末尾与后缀末尾相等，表示前后缀相等，则最大相等前后缀长度为前缀长度(j+1)  
            next[i] = j + 1; // j表示前缀末尾下标，+1表示前缀长度  
            j++; // 扩大前缀，为下一轮比较做准备，因为下一轮后缀也会+1  
        } else {  
            // 前缀末尾与后缀末尾不相等，按照KMP思想，前缀要回退到当前前缀的最大前缀[0,j-1]的next数组的值next[j-1]，  
            // 如当前子串是aabaaf,当前前缀是aab,则当前前缀的最大前缀也即aa的next数组值1，  
            // 直到相等或回退到原始位置  
            while (j > 0 && cs[i] != cs[j]) {  
                j = next[j - 1];  
            }  
            // 重复上面的相等逻辑，更新next数组且前缀后移  
            if (cs[i] == cs[j]) {  
                next[i] = j + 1;  
                j++;  
            }  
        }  
    }  
    return next;  
}
```
代码简化为
```java
private static int[] getNext(char[] cs) {  
    int[] next = new int[cs.length];  
    int j = 0; // 前缀末尾，第一个字符无前缀，初始为0  
    int i = 1; // 后缀末尾，第一个字符无后缀，因此从1开始  
    for (; i < cs.length; i++) {  
        // 前缀末尾与后缀末尾不相等，按照KMP思想，前缀要回退到当前前缀的最大前缀[0,j-1]的next数组的值next[j-1]，  
        // 如当前子串是aabaaf,当前前缀是aab,则当前前缀的最大前缀也即aa的next数组值1，  
        // 直到相等或回退到原始位置  
        while (j > 0 && cs[i] != cs[j]) {  
            j = next[j - 1];  
        }  
        if (cs[i] == cs[j]) {  
            // 前缀末尾与后缀末尾相等，表示前后缀相等，则最大相等前后缀长度为前缀长度(j+1)  
            next[i] = j + 1; // j表示前缀末尾下标，+1表示前缀长度  
            j++; // 扩大前缀，为下一轮比较做准备，因为下一轮后缀也会+1  
        }  
        // 仍不等，则当前next值为默认值0
    }  
    return next;  
}
```
#### 实现KMP算法如下
```java
private static boolean contains(String haystack, String needle) {  
    final char[] hs = haystack.toCharArray();  
    final char[] ns = needle.toCharArray();  
    final int[] next = getNext(ns); // 求取模式串的next数组  
    int j = 0;  
    for (int i = 0; i < hs.length; i++) {  
        // 相等则继续比较下一位  
        if (hs[i] == ns[j]) {  
            j++;  
            if (j == ns.length) {  
                return true;  
            }  
        } else {  
            // 不等则回退到next数组前一位代表的长度的后一位继续比较  
            while (j > 0 && hs[i] != ns[j]) {  
                j = next[j - 1];  
            }  
            // 继续比较，如果回到首位还不等，则直接结束  
            if (hs[i] == ns[j]) {  
                j++;  
            }
        }  
    }  
    return false;  
}
```
优化版本如下:
```java
private static boolean contains(String haystack, String needle) {  
    final char[] hs = haystack.toCharArray();  
    final char[] ns = needle.toCharArray();  
    final int[] next = getNext(ns); // 求取模式串的next数组  
    int j = 0;  
    for (int i = 0; i < hs.length; i++) {  
        // 不相等时则回退到前一个子串的最长相等前后缀中的前缀的后一位开始比较  
        while (j > 0 && hs[i] != ns[j]) {  
            j = next[j - 1];  
        }  
        if (hs[i] == ns[j]) {  
            // 相等则继续比较下一位，到达模式串末尾则直接结束    
            if (j == ns.length - 1) {  
                return true;  
            }  
            j++;
        }
    }  
    return false;  
}
```
#### 顺便解力扣28题
> 给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。
```java
public int strStr(String haystack, String needle) {  
    final char[] hs = haystack.toCharArray();  
    final char[] ns = needle.toCharArray();  
    final int[] next = getNext(ns); // 求取模式串的next数组  
    int j = 0;  
    for (int i = 0; i < hs.length; i++) {  
        // 不相等时则回退到前一个子串的最长相等前后缀中的前缀的后一位开始比较  
        while (j > 0 && hs[i] != ns[j]) {  
            j = next[j - 1];  
        }  
        if (hs[i] == ns[j]) {  
            // 相等则继续比较下一位，到达模式串末尾则直接结束  
            if (j == ns.length - 1) {  
                return i - j;  
            }  
            j++;  
        }  
    }  
    return -1;  
}
```