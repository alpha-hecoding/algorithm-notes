# 55.跳跃游戏
给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。
## 题解
> 并不需要关注怎么跳跃，只要保证每次能跳跃到的最大下标能覆盖下一个下标就行
```java
public boolean canJump(int[] nums) {  
    int maxIndex = 0; // 可跳跃到的最大下标  
    for (int i = 0; i < nums.length - 1; i++) {  
        maxIndex = Integer.max(i + nums[i], maxIndex);  
        if (maxIndex <= i) {  
            return false;  
        }  
    }  
    return true;  
}
```
# 45.跳跃游戏二
给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]`
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。
## 题解
> 每次跳跃时，在可跳跃位置中选定一个位置，跳到该位置时下一步能跳得最远，这样跳跃的步数必然是最小的
```java
class Solution {  
    public int jump(int[] nums) {  
        int result = 0;  
        for (int i = 0; i < nums.length - 1; ) {  
            // 每次跳到的目标位置，为所有可跳跃位置中能继续跳最远的位置  
            int next = i + 1; // 目标位置，默认为当前的下一个位置  
            for (int j = nums[i]; j > 1; j--) {  
                // 可以跳到末尾，则直接结束  
                if (i + j >= nums.length - 1) {  
                    result++;  
                    return result;  
                }  
                // 当前可跳跃位置下一步能跳得更远，则记录下来  
                if (i + j + nums[i + j] > next + nums[next]) {  
                    next = i + j;  
                }  
            }  
            i = next;  
            result++;  
        }  
        return result;  
    }  
}
```
# 1005.K次取反后最大化的数组和
给你一个整数数组 `nums` 和一个整数 `k` ，按以下方法修改该数组：

- 选择某个下标 `i` 并将 `nums[i]` 替换为 `-nums[i]` 。

重复这个过程恰好 `k` 次。可以多次选择同一个下标 `i` 。

以这种方式修改数组后，返回数组 **可能的最大和** 。
## 题解
> 每次翻转绝对值最大的负数，直到没有负数时，翻转最小的正数
```java
class Solution {  
    public int largestSumAfterKNegations(int[] nums, int k) {  
        Arrays.sort(nums); // 先排序  
        int i = 0;  
        while (k > 0) {  
            if (i == nums.length) {  
                // 已超出数组长度，可以推断数组全部为负数，则翻转最后一个  
                nums[i - 1] = -nums[i - 1];  
            } else if (nums[i] < 0) {  
                // 负数直接翻转为对应正数  
                nums[i] = -nums[i];  
                i++;  
            } else if (nums[i] == 0) {  
                // 遇到0则一直翻转0，直接跳出  
                break;  
            } else {  
                // 正数，则看剩余次数  
                if ((k & 1) == 0) {  
                    // 为偶数次则一直翻转该位置，直接跳过  
                    break;  
                } else {  
                    // 为奇数次，则翻转当前位置与前一位置中绝对值较小的值  
                    if (i > 0 && Math.abs(nums[i - 1]) < nums[i]) {  
                        nums[i - 1] = -nums[i - 1];  
                    } else {  
                        nums[i] = -nums[i];  
                    }  
                    break;  
                }  
            }  
            k--;  
        }  
        return Arrays.stream(nums).sum();  
    }  
}
```
# 134.加油站
在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。
## 题解
> 关键是逻辑推理
- 从前一个站点能到当前站点，说明到达当前站点时剩余油量>=0；
- 从当前站点能到下一个站点，说明剩余油量+当前站点加油量>=当前站点出发消耗油量；
> 因此可以继续推理如下
- 如果当前站点无法前往下一站，说明从选取的起始站点到达当前站点的剩余油量<当前站点前往下一站点消耗油量 - 当前站点可加油量；
- 因为到前面每个加油站时剩余油量都>=0，选取其中任一站点作为新的起点，到达当前位置时剩余油量只会更少，更不可能再往下走；
- 因此，只能选取当前站点的后一个站点作为新的起点；
> 综合，结论如下：从选定起点开始往下走时，到达任意站点时，如果不足以继续前往下一站，则只能选取下一站作为新的起点。
```java
public int canCompleteCircuit(int[] gas, int[] cost) {  
    // 不管从哪个加油站开始，能到达当前加油站，则说明汽车当前剩余油量大于等于0，  
    // 从当前加油站继续往下走，如果要消耗的油大于剩余油量与当前加油站能加的油，则无法继续，  
    // 因为到前面每个加油站时剩余油量都是正数或0，选取其中任一站点作为新的起点，到达当前位置时剩余油量只会更少，  
    // 因此，只能选取当前站点的后一个站点作为新的起点  
    int totalRemainGas = 0; // 总剩余油量  
    int remainGas = 0; // 当前剩余油量  
    int start = 0;  
    for (int i = 0; i < gas.length; i++) {  
        totalRemainGas += gas[i] - cost[i];  
        remainGas += gas[i] - cost[i];  
        if (remainGas < 0) {  
            start = i + 1; // 只能从后一个加油站开始  
            remainGas = 0;  
        }  
    }  
    // 总剩余油量为负，肯定不能开完一圈  
    if (totalRemainGas < 0) {  
        return -1;  
    }  
    return start;  
}
```
