# 376.摆动序列
如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3)  是正负交替出现的。相反, [1,4,7,2,5]  和  [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。
## 题解
> 实际为查找峰值与谷值，计算峰点数与谷点数。实际上并不需要严格查找，在遍历过程中出现拐点即计数
```java
class Solution {  
    public int wiggleMaxLength(int[] nums) {  
        int gap = 0;  
        int cnt = 1;  
        for (int i = 1; i < nums.length; i++) {  
            // 当前递增  
            if (nums[i] > nums[i - 1]) {  
                // 之前为递减或平直，则有转折，到新的周期  
                if (gap <= 0) {  
                    gap = nums[i] - nums[i - 1];  
                    cnt++;  
                } else {  
                    // 之前也是递增，则更新差值  
                    gap += nums[i] - nums[i - 1];  
                }  
            } else if (nums[i] < nums[i - 1]) {  
                // 当前递减  
                // 之前为递增或平直，则有转折，到新的周期  
                if (gap >= 0) {  
                    gap = nums[i] - nums[i - 1];  
                    cnt++;  
                } else {  
                    // 之前也是递减，则更新差值  
                    gap += nums[i] - nums[i - 1];  
                }  
            }  
        }  
        return cnt;  
    }  
}
```
# 53.最大子数组和
给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。
## 题解
> 如果之前的和是负数，则与当前值求和只能是做减法，越加越小，因此从当前位置开始重新累积，否则做加法
```java
class Solution {  
    public int maxSubArray(int[] nums) {  
        int max = Integer.MIN_VALUE;  
        int sum = 0;  
        for (int i = 0; i < nums.length; i++) {  
            // 如果之前的和是负数，则与当前值求和只能是做减法，越加越小，因此从当前位置开始重新累积，否则做加法  
            if (sum < 0) {  
                sum = nums[i];  
            } else {  
                sum += nums[i];  
            }  
            max = Integer.max(sum, max);  
        }  
        return max;  
    }  
}
```
# 55.跳跃游戏
给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。
## 题解
> 并不需要关注怎么跳跃，只要保证每次能跳跃到的最大下标能覆盖下一个下标就行
```java
public boolean canJump(int[] nums) {  
    int maxIndex = 0; // 可跳跃到的最大下标  
    for (int i = 0; i < nums.length - 1; i++) {  
        maxIndex = Integer.max(i + nums[i], maxIndex);  
        if (maxIndex <= i) {  
            return false;  
        }  
    }  
    return true;  
}
```
# 45.跳跃游戏二
给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]`
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。
## 题解
> 每次跳跃时，在可跳跃位置中选定一个位置，跳到该位置时下一步能跳得最远，这样跳跃的步数必然是最小的
```java
class Solution {  
    public int jump(int[] nums) {  
        int result = 0;  
        for (int i = 0; i < nums.length - 1; ) {  
            // 每次跳到的目标位置，为所有可跳跃位置中能继续跳最远的位置  
            int next = i + 1; // 目标位置，默认为当前的下一个位置  
            for (int j = nums[i]; j > 1; j--) {  
                // 可以跳到末尾，则直接结束  
                if (i + j >= nums.length - 1) {  
                    result++;  
                    return result;  
                }  
                // 当前可跳跃位置下一步能跳得更远，则记录下来  
                if (i + j + nums[i + j] > next + nums[next]) {  
                    next = i + j;  
                }  
            }  
            i = next;  
            result++;  
        }  
        return result;  
    }  
}
```
# 1005.K次取反后最大化的数组和
给你一个整数数组 `nums` 和一个整数 `k` ，按以下方法修改该数组：

- 选择某个下标 `i` 并将 `nums[i]` 替换为 `-nums[i]` 。

重复这个过程恰好 `k` 次。可以多次选择同一个下标 `i` 。

以这种方式修改数组后，返回数组 **可能的最大和** 。
## 题解
> 每次翻转绝对值最大的负数，直到没有负数时，翻转最小的正数
```java
class Solution {  
    public int largestSumAfterKNegations(int[] nums, int k) {  
        Arrays.sort(nums); // 先排序  
        int i = 0;  
        while (k > 0) {  
            if (i == nums.length) {  
                // 已超出数组长度，可以推断数组全部为负数，则翻转最后一个  
                nums[i - 1] = -nums[i - 1];  
            } else if (nums[i] < 0) {  
                // 负数直接翻转为对应正数  
                nums[i] = -nums[i];  
                i++;  
            } else if (nums[i] == 0) {  
                // 遇到0则一直翻转0，直接跳出  
                break;  
            } else {  
                // 正数，则看剩余次数  
                if ((k & 1) == 0) {  
                    // 为偶数次则一直翻转该位置，直接跳过  
                    break;  
                } else {  
                    // 为奇数次，则翻转当前位置与前一位置中绝对值较小的值  
                    if (i > 0 && Math.abs(nums[i - 1]) < nums[i]) {  
                        nums[i - 1] = -nums[i - 1];  
                    } else {  
                        nums[i] = -nums[i];  
                    }  
                    break;  
                }  
            }  
            k--;  
        }  
        return Arrays.stream(nums).sum();  
    }  
}
```
# 134.加油站
在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。
## 题解
> 关键是逻辑推理
- 从前一个站点能到当前站点，说明到达当前站点时剩余油量>=0；
- 从当前站点能到下一个站点，说明剩余油量+当前站点加油量>=当前站点出发消耗油量；
> 因此可以继续推理如下
- 如果当前站点无法前往下一站，说明从选取的起始站点到达当前站点的剩余油量<当前站点前往下一站点消耗油量 - 当前站点可加油量；
- 因为到前面每个加油站时剩余油量都>=0，选取其中任一站点作为新的起点，到达当前位置时剩余油量只会更少，更不可能再往下走；
- 因此，只能选取当前站点的后一个站点作为新的起点；
> 综合，结论如下：从选定起点开始往下走时，到达任意站点时，如果不足以继续前往下一站，则只能选取下一站作为新的起点。
```java
public int canCompleteCircuit(int[] gas, int[] cost) {  
    // 不管从哪个加油站开始，能到达当前加油站，则说明汽车当前剩余油量大于等于0，  
    // 从当前加油站继续往下走，如果要消耗的油大于剩余油量与当前加油站能加的油，则无法继续，  
    // 因为到前面每个加油站时剩余油量都是正数或0，选取其中任一站点作为新的起点，到达当前位置时剩余油量只会更少，  
    // 因此，只能选取当前站点的后一个站点作为新的起点  
    int totalRemainGas = 0; // 总剩余油量  
    int remainGas = 0; // 当前剩余油量  
    int start = 0;  
    for (int i = 0; i < gas.length; i++) {  
        totalRemainGas += gas[i] - cost[i];  
        remainGas += gas[i] - cost[i];  
        if (remainGas < 0) {  
            start = i + 1; // 只能从后一个加油站开始  
            remainGas = 0;  
        }  
    }  
    // 总剩余油量为负，肯定不能开完一圈  
    if (totalRemainGas < 0) {  
        return -1;  
    }  
    return start;  
}
```
# 860.柠檬水找零
在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。

注意，一开始你手头没有任何零钱。

给你一个整数数组 `bills` ，其中 `bills[i]` 是第 `i` 位顾客付的账。如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。
## 题解
> 关键之处在于确定找零策略
- 收到面额为10的只能用面额为5的找零
- 收到面额为20的优先用10+5的找零，其次用5+5+5的找零
```java
public boolean lemonadeChange(int[] bills) {  
    int countFive = 0; // 面额为5的数量  
    int countTen = 0; // 面额为10的数量  
    int countTwenty = 0; // 面额为20的数量  
    for (int bill : bills) {  
        if (bill == 5) {  
            countFive++;  
        } else if (bill == 10) {  
            if (countFive > 0) {  
                countFive--;  
                countTen++;  
            } else {  
                return false;  
            }  
        } else if (bill == 20) {  
            // 优先使用面额为10的找零，其次使用面额为5的找零  
            if (countTen > 0 && countFive > 0) {  
                countTen--;  
                countFive--;  
                countTwenty++;  
            } else if (countFive >= 3) {  
                countFive -= 3;  
                countTwenty++;  
            } else {  
                return false;  
            }  
        }  
    }  
    return true;  
}
```
# 406.根据身高重建队列
假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。

请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。
## 题解
> 有两个维度的，先确定一个维度。
- 如果先确定人数，意味着相对位置已经确定，再重新调整必然导致位置变化，顺序又会乱；
- 先确定身高，然后按照人数进行插入。因为高个子在前，矮个子往高个子前插入时不会影响高个子位置的人数顺序
```java
class Solution {  
    public int[][] reconstructQueue(int[][] people) {  
        // 按照h来降序排序，高个子人排在前面，相同身高时，按照人数升序排列  
        Arrays.sort(people, (a, b) -> {  
            if (a[0] != b[0]) {  
                return b[0] - a[0];  
            }  
            return a[1] - b[1];  
        });  
        // 调整位置，按照位置人数插入到相应位置，因为是将矮的往前插，不会影响已处理好的顺序  
        for (int i = 1; i < people.length; i++) {  
            int[] tmp = people[i]; // 记录待插入数据  
            // 待插入位置之后的依次向后移动  
            for (int j = i; j > tmp[1]; j--) {  
                people[j] = people[j - 1];  
            }  
            people[tmp[1]] = tmp;  
        }  
        return people;  
    }  
}
```
# 452.用最少数据的箭引爆气球
有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `x``start`，`x``end`， 且满足 `xstart ≤ x ≤ x``end`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组 `points` ，_返回引爆所有气球所必须射出的 **最小** 弓箭数_ 。
## 题解
> 两个区间重叠，可减少一支箭，因此，问题简化为处理后互不重叠的区间数量
- 计算重叠，先按顺序排列区间，依次比较区间与上一个区间是否重叠
- 如果两个区间重叠，再来一个区间时需要看三个区间是否有重叠，而不是与其中任意一个区间是否有重叠
```java
class Solution {  
    public int findMinArrowShots(int[][] points) {  
        // 按区间起始位置排序，判断重叠只要看区间结束位置  
        Arrays.sort(points, Comparator.comparingInt(p -> p[0]));  
        int count = 1; // 最少一个区间，最小一支箭  
        for (int i = 1; i < points.length; i++) {  
            if (points[i][0] <= points[i - 1][1]) {  
                // 与上一区间重叠，减少一支箭，但需要更新区间的结束位置为上一区间与当前区间结束位置的最小位置  
                points[i][1] = Integer.min(points[i - 1][1], points[i][1]);  
            } else {  
                count++;  
            }  
        }  
        return count;  
    }  
}
```
# 435.无重叠区间
给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 _需要移除区间的最小数量，使剩余区间互不重叠_ 。
## 题解
> 与452-用最少数据的箭引爆气球类似，这里是找出重叠区间数，即总区间数-不重叠区间数
```java
class Solution {  
    public int eraseOverlapIntervals(int[][] intervals) {  
        // 按区间起始位置排序  
        Arrays.sort(intervals, Comparator.comparingInt(p -> p[0]));  
        int count = 1; // 不重叠区间数  
        for (int i = 1; i < intervals.length; i++) {  
            if (intervals[i][0] < intervals[i - 1][1]) {  
                // 与前一个区间重叠，需要更新区间结束位置  
                intervals[i][1] = Integer.min(intervals[i - 1][1], intervals[i][1]);  
            } else {  
                count++;  
            }  
        }  
        return intervals.length - count;  
    }  
}
```
# 56.合并区间
以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 _一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间_ 。
```java
class Solution {  
    public int[][] merge(int[][] intervals) {  
        // 按区间起始位置排序  
        Arrays.sort(intervals, Comparator.comparing(p -> p[0]));  
        int[] pre = intervals[0]; // 上一个区间  
        List<int[]> list = new LinkedList<>();  
        for (int i = 1; i < intervals.length; i++) {  
            if (intervals[i][0] <= pre[1]) {  
                // 区间重叠，更新待收割区间结束位置  
                pre[1] = Integer.max(pre[1], intervals[i][1]);  
            } else {  
                // 收割不重叠结果  
                list.add(pre);  
                pre = intervals[i];  
            }  
        }  
        list.add(pre);  
        return list.toArray(new int[0][0]);  
    }  
}
```
# 738.单调递增的数字
当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是**单调递增**的。

给定一个整数 `n` ，返回 _小于或等于 `n` 的最大数字，且数字呈 **单调递增**_ 。
示例：332 => 299
## 题解
> 某个位置数值小于后一位置数值，则当前位置应当减1，后一位置开始都是9，才是最大的单调递增序列
```java
class Solution {  
    public int monotoneIncreasingDigits(int n) {  
        final char[] chars = String.valueOf(n).toCharArray();  
        // 从后往前判断是否是单调递增  
        int maxIndex = chars.length - 1; // 用于记录更新到9的位置的最大下标  
        for (int i = chars.length - 2; i >= 0; i--) {  
            if (chars[i] > chars[i + 1]) {  
                // 当前位置数值小于后一位数值，则后面位置全部改为9，当前位置减1  
                chars[i] = (char) (chars[i] - 1);  
                for (int j = i + 1; j <= maxIndex; j++) {  
                    chars[j] = '9';  
                }  
                maxIndex = i; // 当前位置之后已经是9  
            }  
        }  
        return Integer.parseInt(new String(chars));  
    }  
}
```
# 96.监控二叉树
给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视**其父对象、自身及其直接子对象。**

计算监控树的所有节点所需的最小摄像头数量。
## 题解
> 在叶子节点的父节点上放摄像头，能监视到上下三层，是最优情况。  
> 遍历二叉树适合用深度遍历，先处理子节点，再处理父节点。
### 对二叉树节点标记状态
- 1=该节点有摄像头
- 2=该节点无摄像头，但其左右孩子节点有摄像头，被监视到
- 0=该节点无摄像头，且其左右孩子节点无摄像头，未被监视到
### 根据叶子节点状态处理父节点状态
- (1)子节点无摄像头且未被监视到，则当前节点需要摄像头
- (2)子节点有摄像头，则当前节点会被监视到
- (3)子节点无摄像头但被监视到，则当前节点无摄像头且未被监视到，其父节点需要摄像头
- 处理完所有子节点，需要检查下根节点，因为根节点没有父节点，无法满足(3)中场景
- 空节点等同于2，因为其父节点无需摄像头
```java
class Solution {  
  
    private int count = 0;  
  
    /**  
     * 遍历树，返回节点状态  
     * <li>有摄像头 => 1</li>  
     * <li>无摄像头：被监视到 => 2</li>  
     * <li>无摄像头：未被监视到 => 0</li>  
     */  
    private int traversal(TreeNode root) {  
        if (root == null) {  
            return 2;  
        }  
        int left = traversal(root.left);  
        int right = traversal(root.right);  
        // 左右孩子节点任一无摄像头且未被监视，当前节点需要添加摄像头  
        // 左右孩子节点任一有摄像头，当前节点被监视到  
        // 左右孩子任一无摄像头但被监视到，则当前节点无摄像头未被监视到，向上递归返回  
        if (left == 0 || right == 0) {  
            count++;  
            return 1;  
        } else if (left == 1 || right == 1) {  
            return 2;  
        } else {  
            return 0;  
        }  
    }  
  
    public int minCameraCover(TreeNode root) {  
        final int rootState = traversal(root);  
        // 根节点无摄像头未被监视到，因为没有父级节点了，则额外需要一个摄像头  
        if (rootState == 0) {  
            count++;  
        }  
        return count;  
    }  
}
```
