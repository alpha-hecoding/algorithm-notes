# 总述
> 顾名思义，贪心算法或贪心思想采用贪心的策略，保证每次操作都是局部最优的，从而使最 后得到的结果是全局最优的

# 分配问题
## 问题描述
> 有一群孩子和一堆饼干，每个孩子有一个饥饿度，每个饼干都有一个大小。每个孩子只能吃最多一个饼干，且只有饼干的大小大于等于孩子的饥饿度时，这个孩子才能吃饱。求解最多有多少孩子可以吃饱。
## 解题分析
> 越容易满足的孩子越多，则总满足的孩子最多。因此找到最小食量的孩子，找到满足的最小的饼干，在剩下的孩子与饼干里再次找最小与最小，直到结束。
- 直接解法
```java
public int findContentChildren(int[] g, int[] s) {  
    Arrays.sort(g);  
    Arrays.sort(s);  
    int count = 0;  
    int i = 0; // 孩子指针  
    int j = 0; // 饼干指针  
    while (i < g.length && j < s.length) {  
	    // 找到满足的孩子，消耗了当前的饼干，继续下一轮
        if (g[i] <= s[j]) {  
            count++;  
            i++;  
        }  
        // 饼干不满足，找下一个饼干
        j++;  
    }  
    return count;  
}
```
- 使用小顶堆解法
```java
public int findContentChildren(int[] g, int[] s) {  
    // 使用堆，默认是小顶堆  
    PriorityQueue<Integer> q1 = new PriorityQueue<>();  
    PriorityQueue<Integer> q2 = new PriorityQueue<>();  
    for (int i : g) {  
        q1.add(i);  
    }  
    for (int j : s) {  
        q2.add(j);  
    }  
    int count = 0;  
    Integer p1 = q1.poll();  
    Integer p2 = q2.poll();  
    while (p1 != null && p2 != null) {  
        if (p1 <= p2) {  
            count++;  
            p1 = q1.poll();  
        }  
        p2 = q2.poll();  
    }  
    return count;
}
```