# 总述
> 顾名思义，贪心算法或贪心思想采用贪心的策略，保证每次操作都是局部最优的，从而使最 后得到的结果是全局最优的

# 分配问题(455)
## 问题描述
> 有一群孩子和一堆饼干，每个孩子有一个饥饿度，每个饼干都有一个大小。每个孩子只能吃最多一个饼干，且只有饼干的大小大于等于孩子的饥饿度时，这个孩子才能吃饱。求解最多有多少孩子可以吃饱。
## 解题分析
> 越容易满足的孩子越多，则总满足的孩子最多。因此找到最小食量的孩子，找到满足的最小的饼干，在剩下的孩子与饼干里再次找最小与最小，直到结束。
- 直接解法
```java
public int findContentChildren(int[] g, int[] s) {  
    Arrays.sort(g);  
    Arrays.sort(s);  
    int count = 0;  
    int i = 0; // 孩子指针  
    int j = 0; // 饼干指针  
    while (i < g.length && j < s.length) {  
	    // 找到满足的孩子，消耗了当前的饼干，继续下一轮
        if (g[i] <= s[j]) {  
            count++;  
            i++;  
        }  
        // 饼干不满足，找下一个饼干
        j++;  
    }  
    return count;  
}
```
- 使用小顶堆解法
```java
public int findContentChildren(int[] g, int[] s) {  
    // 使用堆，默认是小顶堆  
    PriorityQueue<Integer> q1 = new PriorityQueue<>();  
    PriorityQueue<Integer> q2 = new PriorityQueue<>();  
    for (int i : g) {  
        q1.add(i);  
    }  
    for (int j : s) {  
        q2.add(j);  
    }  
    int count = 0;  
    Integer p1 = q1.poll();  
    Integer p2 = q2.poll();  
    while (p1 != null && p2 != null) {  
        if (p1 <= p2) {  
            count++;  
            p1 = q1.poll();  
        }  
        p2 = q2.poll();  
    }  
    return count;
}
```
# 分发糖果(135)
> n个孩子站成一排，每个孩子至少分配一个糖果，相邻孩子评分更高的需要分配更多的糖果。
## 解题思路
> 贪心策略为：每次保证一边的孩子的糖果分配符合评分高则分配多的规则。遍历两边完成两边孩子的分配，则分配完成。
```java
public int candy(int[] ratings) {  
    int[] candies = new int[ratings.length];  
    // 从左到右，相邻右孩子比当前孩子评分高则其糖果数比当前孩子糖果数+1  
    for (int i = 0; i < ratings.length - 1; i++) {  
        if (ratings[i + 1] > ratings[i]) {  
            candies[i + 1] = candies[i] + 1;  
        }  
    }  
    // 从右到左，相邻左孩子比当前孩子评分高则其糖果数比当前孩子糖果数+1  
    for (int i = ratings.length - 1; i > 0; i--) {  
        if (ratings[i - 1] > ratings[i] && candies[i - 1] <= candies[i]) {  
            candies[i - 1] = candies[i] + 1;  
        }  
    }  
    // 求和  
    int sum = 0;  
    for (int i = 0; i < candies.length; i++) {  
        sum += candies[i];  
    }  
    // 总数记上每个孩子的初始糖果数1  
    return sum + candies.length;  
}
```
# 区间问题(435)
> 给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 _需要移除区间的最小数量，使剩余区间互不重叠。_
## 解题思路
> 考虑区间尾部，尾部越小，则留给其它区间选择的空间越大，尾部越大，则留给其它区间选择的空间越小。因此每次都选择尾部最小的区间，判断与前一个保留的区间是否重叠，不重叠的保留，重叠的移除。
```java
public int eraseOverlapIntervals(int[][] intervals) {  
    int removed = 0;  
    // 按照区间尾部排序  
    Arrays.sort(intervals, Comparator.comparingInt(p -> p[1]));  
    int pre = 0; // 前一个保留的区间  
    for (int i = 1; i < intervals.length; i++) {  
        if (intervals[i][0] < intervals[pre][1]) {  
            // 当前区间的起始在前一个区间的尾部之前，发生重叠  
            ++removed;  
        } else {  
            pre = i;  
        }  
    }  
    return removed;  
}
```
# 种花问题(605)
> 假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。  
> 给你一个整数数组 `flowerbed` 表示花坛，由若干 `0` 和 `1` 组成，其中 `0` 表示没种植花，`1` 表示种植了花。另有一个数 `n` ，能否在不打破种植规则的情况下种入 `n` 朵花？能则返回 `true` ，不能则返回 `false` 。
## 解题思路
> 能种的地方在头部则要求前两块儿地为空，在尾部则要求最后两块儿地为空，在中间则要求连续三块儿地为空。一块儿地已种，则其下一块儿必然为空。  
> 贪心思路为每次找三块儿连续为空的

```java
public boolean canPlaceFlowers(int[] flowerbed, int n) {  
    // 种子已种完，则直接结束  
    for (int i = 0; i < flowerbed.length && n > 0; ) {  
        if (flowerbed[i] == 1) {  
            i += 2; // 当前位置已种，则下一块儿肯定未种，只需要看下下一块儿  
        } else if (i == flowerbed.length - 1 || flowerbed[i + 1] == 0) {  
            // 当前位置未种，如果是最后一块儿或下一块儿也未种，则可种  
            n--;  
            i += 2;  
        } else {  
            // 当前位置未种，但下一块儿已种，则下下块儿未种，只需要看下下下块儿  
            i += 3;  
        }  
    }  
    return n <= 0;  
}
```
# 用最少数量的箭引爆气球(452)
> 类似区间问题(435)，弓箭数即为重叠区间分组的组数
```java
public int findMinArrowShots(int[][] points) {  
    if (points.length == 0) {  
        return 0;  
    }  
    // 按照区间尾部排序  
    Arrays.sort(points, Comparator.comparingInt(p -> p[1]));  
    int pre = 0; // 当前计算重叠区间的起始区间  
    int count = 1; // 射箭的数量  
    for (int i = 1; i < points.length; i++) {  
        // 超出上一个区间，重新开始  
        if (points[i][0] > points[pre][1]) {  
            count++;  
            pre = i;  
        }  
    }  
    return count;  
}
```
# 划分字母区间
> 给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。返回一个表示每个字符串片段的长度的列表。
## 解题思路
> 记录字符的最终出现位置，以便计算当前子串的结束位置。需要动态更新子串的最终结束位置
```java
public List<Integer> partitionLabels(String s) {  
    final char[] chars = s.toCharArray();  
    // 记录字符的结束位置  
    Map<Character, Integer> map = new HashMap<>();  
    for (int i = 0; i < chars.length; i++) {  
        map.put(chars[i], i);  
    }  
    List<Integer> list = new ArrayList<>();  
    int start = 0; // 当前起始位置  
    int expect = 0; // 当前子串的期望结束位置  
    for (int i = 0; i < chars.length; i++) {  
        // 期望字符结束位置小于当前下标，之前为完整子串  
        if (expect < i) {  
            list.add(expect - start + 1);  
            // 重置新的子串的起始和期望  
            start = i;  
            expect = i;  
        }  
        final int et = map.get(chars[i]);  
        // 当前字符结束位置大于期望位置，则更新期望位置  
        if (et > expect) {  
            expect = et;  
        }  
        // 判断最新的expect是否已经到末尾，到达末尾直接结束
        if (expect == chars.length - 1) {  
            list.add(expect - start + 1);  
            break;  
        }  
    }  
    return list;  
}
```
# 买卖股票的最佳时机二(122)
> 给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。返回 _你能获得的 **最大** 利润_ 。
## 解题思路
> 只要继续赚就一直持有，只要一跌就前一天卖出，保证截止到当前是赚最多的。卖完后只要继续下跌就标记为新一轮的买入日期，直到新的一轮卖出。即每一轮都保证最大收益。
```java
public int maxProfit(int[] prices) {  
    int max = 0;  
    int buyIndex = 0;  // 买入日期
    for (int i = 1; i < prices.length; i++) {  
        if (prices[i] < prices[i - 1] && prices[i - 1] > prices[buyIndex]) {  
            // 如果跌了且盈利，则于前一天卖出，且记录当天为新的买入日期  
            max += prices[i - 1] - prices[buyIndex];  
            buyIndex = i;  
        } else if (i == prices.length - 1 && prices[i] > prices[buyIndex]) {  
            // 最后一天，如果是盈利，则卖出  
            max += prices[i] - prices[buyIndex];  
        } else if (prices[i] < prices[i - 1]) {  
            // 如果跌了，则更新买入日期  
            buyIndex = i;  
        }  
    }  
    return max;  
}
```
